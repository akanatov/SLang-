Row:Col	Code	Token string
1:1	3	 Core units to represent basic SLang types  (WIP - not all features are fully implemented!!! )
2:1	3	 Version 0.93 Dec 14th 2020
4:1	43	val
4:6	41	unit
4:12	2	Bit
5:9	15	const
6:19	7	0b0
6:22	57	,
6:25	7	0b1
7:9	19	end
8:3	31	pure
8:9	4	&
8:12	11	alias
8:19	2	and
8:24	48	(
8:25	2	other
8:30	56	:
8:33	12	as
8:37	40	this
8:41	49	)
8:42	56	:
8:45	12	as
8:49	40	this
8:55	4	=>
8:59	24	if
8:63	40	this
8:69	4	=
8:72	7	0b0
8:77	16	do
8:81	7	0b0
8:86	18	elsif
8:93	2	other
8:100	4	=
8:103	7	0b0
8:108	16	do
8:112	7	0b0
8:117	17	else
8:123	7	0b1
10:3	31	pure
10:9	4	|
10:12	11	alias
10:19	2	or
10:23	48	(
10:24	2	other
10:29	56	:
10:32	12	as
10:36	40	this
10:40	49	)
10:41	56	:
10:44	12	as
10:48	40	this
10:54	4	=>
10:58	24	if
10:62	40	this
10:68	4	=
10:71	7	0b1
10:76	16	do
10:80	7	0b1
10:85	18	elsif
10:92	2	other
10:99	4	=
10:102	7	0b1
10:107	16	do
10:111	7	0b1
10:116	17	else
10:122	7	0b0
12:3	31	pure
12:9	4	^
12:12	11	alias
12:19	2	xor
12:24	48	(
12:25	2	other
12:30	56	:
12:33	12	as
12:37	40	this
12:41	49	)
12:42	56	:
12:45	12	as
12:49	40	this
12:55	4	=>
12:59	24	if
12:63	40	this
12:69	4	=
12:72	2	other
12:79	16	do
12:83	7	0b0
12:88	17	else
12:94	7	0b1
14:3	31	pure
14:9	54	~
14:12	11	alias
14:19	2	not
14:24	48	(
14:25	49	)
14:26	56	:
14:29	12	as
14:33	40	this
14:39	4	=>
14:43	24	if
14:47	40	this
14:53	4	=
14:56	7	0b0
14:61	16	do
14:65	7	0b1
14:70	17	else
14:76	7	0b0
16:3	31	pure
16:9	4	+
16:12	48	(
16:13	2	other
16:18	56	:
16:21	12	as
16:25	40	this
16:29	49	)
16:30	56	:
16:33	12	as
16:37	40	this
16:43	16	do
17:5	3	/ Definition of addition
18:5	24	if
18:9	40	this
18:15	4	=
18:18	7	0b0
18:23	16	do
19:7	35	return
19:15	2	other
20:5	18	elsif
20:12	2	other
20:19	4	=
20:22	7	0b1
20:27	16	do
21:7	32	raise
21:14	8	Bit overflow
22:5	17	else
23:7	35	return
23:15	7	0b1
24:5	19	end
25:3	19	end
25:8	3	 +
26:3	31	pure
26:9	4	-
26:12	48	(
26:13	2	other
26:18	56	:
26:21	12	as
26:25	40	this
26:29	49	)
26:30	56	:
26:33	12	as
26:37	40	this
26:43	16	do
27:5	3	/ Definition of subtraction 
28:5	24	if
28:9	40	this
28:15	4	=
28:18	2	other
28:25	16	do
29:7	35	return
29:15	7	0b0
30:5	18	elsif
30:12	40	this
30:18	4	=
30:21	7	0b1
30:26	16	do
31:7	35	return
31:15	7	0b1
32:5	17	else
33:7	32	raise
33:14	8	Bit underflow
34:5	19	end
35:3	19	end
35:8	3	 -
36:1	19	end
39:1	45	virtual
39:10	41	unit
39:16	48	(
39:17	49	)
39:20	3	 That is tuple unit
41:3	48	(
41:4	49	)
41:7	48	(
41:8	2	pos
41:11	56	:
41:14	2	Integer
41:25	2	value
41:30	56	:
41:33	2	Any
41:36	49	)
42:3	3	/ It puts element into tuple at position, put by position
43:3	34	require
44:5	2	pos
44:10	25	in
44:14	5	1
44:17	58	..
44:21	2	count
44:28	3	/ Valid elelment position
45:3	23	foreign
46:3	19	end
46:8	3	 ()
48:3	48	(
48:4	49	)
48:7	48	(
48:8	2	fieldName
48:17	56	:
48:20	2	String
48:30	2	value
48:35	56	:
48:38	2	Any
48:41	49	)
49:3	3	/ It puts element into field called fieldName, put by name
50:3	34	require
51:5	2	fieldIndex
51:15	48	(
51:16	2	fieldName
51:25	49	)
51:28	4	>
51:31	5	0
51:34	3	/ Tuple must have this field
52:3	23	foreign
53:3	19	end
53:8	3	 ()
55:3	31	pure
55:9	48	(
55:10	49	)
55:13	48	(
55:14	2	index
55:19	56	:
55:22	2	Integer
55:29	49	)
55:30	56	:
55:33	2	Any
56:3	3	/ Get tuple element at at postion index
57:3	34	require
58:5	2	index
58:12	25	in
58:16	5	1
58:19	58	..
58:23	2	count
58:30	3	/ Valid index
59:3	23	foreign
60:3	19	end
62:3	31	pure
62:9	48	(
62:10	49	)
62:13	48	(
62:14	2	fieldName
62:23	56	:
62:26	2	String
62:32	49	)
62:33	56	:
62:36	2	Any
63:3	3	/ Get tuple element by fieldName
64:3	34	require
65:5	2	fieldIndex
65:15	48	(
65:16	2	fieldName
65:25	49	)
65:28	4	>
65:31	5	0
65:34	3	/ Tuple must have this field
66:3	23	foreign
67:3	19	end
69:3	31	pure
69:9	2	count
69:14	56	:
69:17	2	Integer
70:3	3	/ Return the number of elelemnts in the tuple
71:3	23	foreign
72:3	19	end
74:3	50	{
74:4	40	this
74:8	51	}
74:11	2	fieldIndex
74:23	48	(
74:24	2	fieldNAme
74:33	56	:
74:36	2	String
74:42	49	)
74:43	56	:
74:46	2	Integer
75:3	23	foreign
76:3	20	ensure
77:5	35	return
77:13	25	in
77:17	5	0
77:20	58	..
77:24	2	count
77:31	3	/ If no such field then 0 otherwise valid position
78:3	19	end
80:1	34	require
81:3	2	count
81:10	4	>=
81:14	5	0
81:17	3	/ Tuple has 0 or more elements
82:1	19	end
84:1	43	val
84:6	41	unit
84:12	2	Bit
84:17	52	[
84:18	2	N
84:19	56	:
84:22	2	Integer
84:29	53	]
85:3	15	const
86:11	50	{
86:12	2	Bit
86:15	59	.
86:16	7	0b0
86:21	4	|
86:24	2	Bit
86:27	59	.
86:28	7	0b1
86:31	51	}
86:32	2	N
87:3	19	end
88:3	50	{
88:4	51	}
88:7	2	data
88:11	56	:
88:14	43	val
88:19	2	Array
88:26	52	[
88:27	5	0
88:29	58	..
88:29	59	.
88:30	2	N
88:31	4	-
88:32	5	1
88:33	57	,
88:36	2	Bit
88:39	53	]
88:42	3	 Bit field ...
89:3	55	:=
89:7	48	(
89:8	2	other
89:13	56	:
89:16	2	Integer
89:23	49	)
89:26	16	do
90:3	3	/ Set N low bits from Integer other into this
91:3	3	 WIP!!!
92:5	32	raise
92:12	8	Not implemented!!!
93:5	3	 WIP What if number of bits in Integer is less than N ?????
95:5	47	while
95:12	2	pos
95:17	25	in
95:21	5	0
95:23	58	..
95:23	59	.
95:26	2	N
95:29	4	-
95:32	5	1
95:35	16	do
96:7	40	this
96:13	48	(
96:14	2	pos
96:17	49	)
96:20	55	:=
96:24	2	other
96:29	59	.
96:30	2	data
96:36	48	(
96:37	2	pos
96:40	49	)
97:5	19	end
98:3	19	end
99:3	30	override
99:13	31	pure
99:19	2	sizeof
99:25	56	:
99:28	2	Integer
99:37	16	do
100:5	3	 return sizeof in bytes !!!! N is a number of bits !!!
101:5	35	return
101:13	2	N
101:16	4	/
101:19	2	Platform
101:27	59	.
101:28	2	BitsInByteCount
101:45	4	+
101:48	24	if
101:52	2	N
101:55	4	\
101:58	2	Platform
101:66	59	.
101:67	2	BitsInByteCount
101:84	4	=
101:87	5	0
101:90	16	do
101:94	5	0
101:97	17	else
101:103	5	1
102:3	19	end
103:3	31	pure
103:9	4	&
103:12	11	alias
103:19	2	and
103:24	48	(
103:25	2	other
103:30	56	:
103:33	12	as
103:37	40	this
103:41	49	)
103:42	56	:
103:45	12	as
103:49	40	this
103:55	16	do
104:5	2	result
104:13	27	is
104:17	40	this
105:5	47	while
105:12	2	pos
105:17	25	in
105:21	5	0
105:24	58	..
105:28	2	N
105:31	4	-
105:34	5	1
105:37	16	do
106:7	2	result
106:15	48	(
106:16	2	pos
106:19	49	)
106:22	55	:=
106:26	24	if
106:30	40	this
106:34	48	(
106:35	2	pos
106:38	49	)
106:41	4	=
106:44	5	0
106:47	2	or
106:51	17	else
106:57	2	other
106:62	48	(
106:63	2	pos
106:66	49	)
106:69	4	=
106:72	5	0
106:75	16	do
106:79	5	0
106:82	17	else
106:88	5	1
107:5	19	end
108:5	35	return
108:13	2	result
109:3	19	end
109:8	3	 and
110:3	31	pure
110:9	4	|
110:12	11	alias
110:19	2	or
110:23	48	(
110:24	2	other
110:29	56	:
110:32	12	as
110:36	40	this
110:40	49	)
110:41	56	:
110:44	12	as
110:48	40	this
110:54	16	do
111:5	2	result
111:13	27	is
111:17	40	this
112:5	47	while
112:12	2	pos
112:17	25	in
112:21	5	0
112:24	58	..
112:28	2	N
112:31	4	-
112:34	5	1
112:37	16	do
113:7	2	result
113:15	48	(
113:16	2	pos
113:19	49	)
113:22	55	:=
113:26	24	if
113:30	40	this
113:34	48	(
113:35	2	pos
113:38	49	)
113:41	4	=
113:44	5	1
113:47	2	or
113:51	17	else
113:57	2	other
113:64	48	(
113:65	2	pos
113:68	49	)
113:71	4	=
113:74	5	1
113:77	16	do
113:81	5	1
113:84	17	else
113:90	5	0
114:5	19	end
115:5	35	return
115:13	2	result
116:3	19	end
116:8	3	 or
117:3	31	pure
117:9	4	^
117:12	11	alias
117:19	2	xor
117:24	48	(
117:25	2	other
117:30	56	:
117:33	12	as
117:37	40	this
117:41	49	)
117:42	56	:
117:45	12	as
117:49	40	this
117:55	16	do
118:5	2	result
118:13	27	is
118:17	40	this
119:5	47	while
119:12	2	pos
119:17	25	in
119:21	5	0
119:24	58	..
119:28	2	N
119:31	4	-
119:34	5	1
119:37	16	do
120:7	2	result
120:15	48	(
120:16	2	pos
120:19	49	)
120:22	55	:=
120:26	24	if
120:30	40	this
120:36	48	(
120:37	2	pos
120:40	49	)
120:43	4	=
120:46	2	other
120:51	48	(
120:52	2	pos
120:55	49	)
120:58	16	do
120:62	5	0
120:65	17	else
120:71	5	1
121:5	19	end
122:5	35	return
122:13	2	result
123:3	19	end
124:3	31	pure
124:9	54	~
124:12	11	alias
124:19	2	not
124:24	48	(
124:25	49	)
124:26	56	:
124:29	12	as
124:33	40	this
124:39	16	do
125:5	2	result
125:13	27	is
125:17	40	this
126:5	47	while
126:12	2	pos
126:17	25	in
126:21	5	0
126:24	58	..
126:28	2	N
126:31	4	-
126:34	5	1
126:37	16	do
127:7	2	result
127:13	59	.
127:14	2	toggle
127:22	48	(
127:23	2	pos
127:26	49	)
128:5	19	end
129:5	35	return
129:13	2	result
130:3	19	end
130:8	3	 not
131:3	48	(
131:4	49	)
131:7	48	(
131:8	2	pos
131:11	56	:
131:14	2	Integer
131:25	2	value
131:30	56	:
131:33	2	Boolean
131:40	49	)
132:3	34	require
133:5	2	pos
133:10	25	in
133:14	5	0
133:17	58	..
133:21	2	N
133:24	4	-
133:27	5	1
133:30	3	/ Valid bit position
134:3	16	do
135:5	40	this
135:11	48	(
135:12	2	pos
135:15	49	)
135:18	55	:=
135:22	24	if
135:26	2	value
135:33	16	do
135:37	5	1
135:40	17	else
135:46	5	0
136:3	19	end
136:8	3	 ()
137:3	48	(
137:4	49	)
137:7	48	(
137:8	2	pos
137:11	56	:
137:14	2	Integer
137:25	2	value
137:30	56	:
137:33	2	Integer
137:40	49	)
138:3	3	/ Set bit as position 'pos' to value 'value'
139:3	34	require
140:5	2	pos
140:10	25	in
140:14	5	0
140:17	58	..
140:21	2	N
140:24	4	-
140:27	5	1
140:30	3	/ Valid bit position
141:5	2	value
141:12	25	in
141:16	5	0
141:18	58	..
141:18	59	.
141:19	5	1
141:22	3	/ Valid value
142:3	16	do
143:5	24	if
143:9	2	value
143:16	4	=
143:19	5	0
143:22	16	do
144:7	2	data
144:13	48	(
144:14	2	pos
144:17	49	)
144:20	55	:=
144:24	7	0b0
145:5	17	else
146:7	2	data
146:13	48	(
146:14	2	pos
146:17	49	)
146:20	55	:=
146:24	7	0b1
147:5	19	end
148:3	19	end
148:8	3	 ()
149:3	31	pure
149:9	48	(
149:10	49	)
149:13	48	(
149:14	2	pos
149:17	56	:
149:20	2	Integer
149:27	49	)
149:28	56	:
149:31	2	Boolean
150:3	34	require
151:5	2	pos
151:10	25	in
151:14	5	0
151:17	58	..
151:21	2	N
151:24	4	-
151:27	5	1
151:30	3	 Valid position
152:3	16	do
153:5	35	return
153:13	40	this
153:19	48	(
153:20	2	pos
153:23	49	)
153:26	4	=
153:29	7	0b1
154:3	19	end
154:8	3	 ()
155:3	31	pure
155:9	48	(
155:10	49	)
155:13	48	(
155:14	2	pos
155:17	56	:
155:20	2	Integer
155:27	49	)
155:28	56	:
155:31	2	Integer
156:3	3	/ Get bit value at position 'pos'
157:3	34	require
158:5	2	pos
158:10	25	in
158:14	5	0
158:17	58	..
158:21	2	N
158:24	4	-
158:27	5	1
158:30	3	/ Valid position	 
159:3	16	do
160:5	24	if
160:9	48	(
160:10	2	data
160:16	48	(
160:17	2	pos
160:20	49	)
160:23	4	=
160:26	7	0b0
160:29	49	)
161:7	35	return
161:15	5	0
162:5	17	else
163:7	35	return
163:15	5	1
164:5	19	end
165:3	20	ensure
166:5	35	return
166:13	25	in
166:17	5	0
166:19	58	..
166:19	59	.
166:20	5	1
166:23	3	/ Valid Integer from Bit 
167:3	19	end
167:8	3	 ()
168:3	31	pure
168:9	2	toInteger
168:18	56	:
168:21	2	Integer
168:30	16	do
169:5	3	/ Build Integer from Bit
170:5	44	var
170:10	2	result
170:18	27	is
170:22	5	0
171:5	44	var
171:10	2	factor
171:18	27	is
171:22	5	1
172:5	47	while
172:12	2	pos
172:17	25	in
172:21	5	0
172:24	58	..
172:28	2	N
172:31	4	-
172:34	5	1
172:37	16	do
173:7	24	if
173:11	40	this
173:17	48	(
173:18	2	pos
173:21	49	)
173:24	4	=
173:27	5	1
173:30	16	do
174:9	2	result
174:17	55	:=
174:21	2	result
174:29	4	+
174:32	2	factor
175:9	2	factor
175:17	55	:=
175:21	2	factor
175:29	4	*
175:32	5	2
176:7	19	end
177:5	19	end
178:5	35	return
178:13	2	result
179:3	19	end
179:8	3	 ToInteger
180:3	31	pure
180:9	2	getLowBits
180:21	48	(
180:22	2	bitsCount
180:31	56	:
180:34	2	Integer
180:41	49	)
180:44	56	:
180:47	2	Bit
180:52	52	[
180:53	2	bitsCount
180:62	53	]
181:3	34	require
182:5	2	bitsCount
182:16	25	in
182:20	5	1
182:23	58	..
182:27	2	N
182:30	3	/ Valid Bits Count
183:3	16	do
184:5	2	result
184:13	27	is
184:17	2	Bit
184:22	52	[
184:23	2	bitsCount
184:32	53	]
184:35	3	 Hmmm .... Dynamic bit field allocation
185:5	47	while
185:12	2	pos
185:17	25	in
185:21	5	0
185:24	58	..
185:28	2	bitsCount
185:39	4	-
185:42	5	1
185:45	16	do
186:7	2	result
186:15	48	(
186:16	2	pos
186:19	49	)
186:22	55	:=
186:26	40	this
186:32	48	(
186:33	2	pos
186:36	49	)
187:5	19	end
188:5	35	return
188:13	2	result
189:3	19	end
189:8	3	 getLowBits
190:3	2	toggle
190:11	48	(
190:12	2	pos
190:15	56	:
190:18	2	Integer
190:25	49	)
191:3	34	require
192:5	2	pos
192:10	25	in
192:14	5	0
192:17	58	..
192:21	2	N
192:24	4	-
192:27	5	1
192:30	3	/ validPos
193:3	16	do
194:5	40	this
194:11	48	(
194:12	2	pos
194:15	49	)
194:18	55	:=
194:22	24	if
194:26	40	this
194:32	48	(
194:33	2	pos
194:36	49	)
194:39	4	=
194:42	5	1
194:45	16	do
194:49	5	0
194:52	17	else
194:58	5	1
195:3	20	ensure
196:5	48	(
196:8	29	old
196:13	40	this
196:19	49	)
196:20	48	(
196:21	2	pos
196:24	49	)
196:27	4	/=
196:31	40	this
196:37	48	(
196:38	2	pos
196:41	49	)
196:44	3	/ bit Toggled
197:3	19	end
197:8	3	 toggle
198:3	26	init
198:9	16	do
199:5	3	/ Every BIT field is initialized with 0s
200:5	47	while
200:12	2	pos
200:17	25	in
200:21	5	0
200:24	58	..
200:28	2	N
200:31	4	-
200:34	5	1
200:37	16	do
201:7	40	this
201:13	48	(
201:14	2	pos
201:17	49	)
201:20	55	:=
201:24	7	0b0
202:5	19	end
203:3	19	end
203:8	3	 init
204:1	34	require
205:3	2	N
205:6	4	>
205:9	5	0
205:12	3	/ Number of Bits is greater than zero
206:1	19	end
206:6	3	 Bit
208:1	45	virtual
208:10	41	unit
208:16	2	Any
208:21	42	use
208:26	15	const
208:33	2	Integer
208:40	57	,
208:43	2	Real
208:47	57	,
208:50	2	Boolean
208:57	57	,
208:60	2	Character
208:69	57	,
208:72	2	String
208:78	57	,
208:81	2	Bit
208:86	52	[
208:87	5	2
208:90	4	**
208:94	2	Integer
208:101	59	.
208:102	2	MaxInteger
208:112	53	]
209:3	3	 Adding all constant objects from basic units allows to use these constants without respective unit name prefix.
212:3	3	/ Shallow equality tests
213:9	4	=
213:12	48	(
213:13	2	that
213:17	56	:
213:20	60	?
213:23	12	as
213:27	40	this
213:33	49	)
213:34	56	:
213:37	2	Boolean
213:46	23	foreign
214:3	12	final
214:10	4	/=
214:14	48	(
214:15	2	that
214:19	56	:
214:22	60	?
214:25	12	as
214:29	40	this
214:35	49	)
214:36	56	:
214:39	2	Boolean
214:48	4	=>
214:52	2	not
214:57	48	(
214:60	40	this
214:66	4	=
214:69	2	that
214:73	49	)
215:9	4	=
215:12	48	(
215:13	2	that
215:17	56	:
215:20	12	as
215:24	40	this
215:28	49	)
215:29	56	:
215:32	2	Boolean
215:41	23	foreign
216:3	12	final
216:10	4	/=
216:14	48	(
216:15	2	that
216:19	56	:
216:22	12	as
216:26	40	this
216:32	49	)
216:33	56	:
216:36	2	Boolean
216:45	4	=>
216:49	2	not
216:54	48	(
216:57	40	this
216:63	4	=
216:66	2	that
216:70	49	)
218:3	3	/ Deep equality tests
219:9	4	==
219:13	48	(
219:14	2	that
219:18	56	:
219:21	60	?
219:24	12	as
219:28	40	this
219:34	49	)
219:35	56	:
219:38	2	Boolean
219:47	23	foreign
220:3	12	final
220:10	4	/=
220:12	4	=
220:15	48	(
220:16	2	that
220:20	56	:
220:23	60	?
220:26	12	as
220:30	40	this
220:36	49	)
220:37	56	:
220:40	2	Boolean
220:49	4	=>
220:53	2	not
220:58	48	(
220:61	40	this
220:67	4	==
220:71	2	that
220:75	49	)
221:9	4	==
221:13	48	(
221:14	2	that
221:18	56	:
221:21	12	as
221:25	40	this
221:29	49	)
221:30	56	:
221:33	2	Boolean
221:42	23	foreign
222:3	12	final
222:10	4	/=
222:12	4	=
222:15	48	(
222:16	2	that
222:20	56	:
222:23	12	as
222:27	40	this
222:33	49	)
222:34	56	:
222:37	2	Boolean
222:46	4	=>
222:50	2	not
222:55	48	(
222:58	40	this
222:64	4	==
222:68	2	that
222:72	49	)
224:3	3	/ Assignment definition
225:3	3	 {} := (that: ? as this ) foreign 
226:3	3	 Caveat !!! Check!!! 
		a1, a2: ? Type
		a1 := a2 // Valid !
		a1 := Type // Valid !
	
231:3	50	{
231:4	51	}
231:7	55	:=
231:11	48	(
231:12	2	that
231:16	56	:
231:19	12	as
231:23	40	this
231:29	49	)
231:32	23	foreign
233:3	3	/ Utility
234:3	2	toString
234:11	56	:
234:14	2	String
234:22	23	foreign
235:3	2	sizeof
235:9	56	:
235:12	2	Integer
235:21	23	foreign
237:1	19	end
237:6	3	 Any
239:1	12	final
239:8	41	unit
239:14	2	System
240:3	2	clone
240:10	48	(
240:11	2	object
240:17	56	:
240:20	2	Any
240:23	49	)
240:24	56	:
240:27	12	as
240:31	2	object
240:39	23	foreign
241:5	3	/ Shallow version of the object clone operation
242:3	2	deepClone
242:14	48	(
242:15	2	object
242:21	56	:
242:24	2	Any
242:27	49	)
242:28	56	:
242:31	12	as
242:35	2	object
242:43	23	foreign
243:5	3	/ Deep version of the object clone operation
244:1	19	end
244:6	3	 System
246:1	12	final
246:8	41	unit
246:14	2	Platform
247:3	2	BitsInByteCount
247:20	27	is
247:24	5	8
248:3	2	IntegerBitsCount
248:21	27	is
248:25	5	32
249:3	2	CardinalBitsCount
249:22	27	is
249:26	2	IntegerBitsCount
250:3	2	CharacterBitsCount
250:23	27	is
250:27	5	8
251:3	2	BooleanBitsCount
251:21	27	is
251:25	5	8
252:3	2	PointerBitsCount
252:21	27	is
252:25	5	32
253:3	2	RealBitsCount
253:18	27	is
253:22	5	64
254:3	2	RealMantissaBitsCount
254:26	27	is
254:30	5	55
255:3	2	RealOrderBitsCount
255:23	27	is
255:27	5	8
256:1	34	require
257:3	2	RealBitsCount
257:18	4	=
257:21	2	RealMantissaBitsCount
257:44	4	+
257:47	2	RealOrderBitsCount
257:67	4	+
257:70	5	1
258:1	19	end
258:6	3	 Platform
260:1	45	virtual
260:10	41	unit
260:16	2	Numeric
261:3	2	one
261:6	56	:
261:9	12	as
261:13	40	this
261:19	45	virtual
262:5	3	/ Definition of One
263:3	2	zero
263:7	56	:
263:10	12	as
263:14	40	this
263:20	45	virtual
264:5	3	/ Definition of Zero
265:3	4	+
265:6	48	(
265:7	2	other
265:12	56	:
265:15	12	as
265:19	40	this
265:23	49	)
265:24	56	:
265:27	12	as
265:31	40	this
265:37	45	virtual
266:5	3	/ Definition of addition
267:3	20	ensure
268:5	40	this
268:11	4	-
268:14	2	other
268:21	4	=
268:24	29	old
268:29	40	this
269:3	19	end
269:8	3	 +
270:3	4	-
270:6	48	(
270:7	2	other
270:12	56	:
270:15	12	as
270:19	40	this
270:23	49	)
270:24	56	:
270:27	12	as
270:31	40	this
270:37	45	virtual
271:5	3	/ Definition of subtraction 
272:3	20	ensure
273:5	40	this
273:11	4	+
273:14	2	other
273:21	4	=
273:24	29	old
273:29	40	this
274:3	19	end
274:8	3	 -
275:3	4	-
275:6	56	:
275:9	12	as
275:13	40	this
275:19	45	virtual
276:5	3	/ Definition of negation
277:3	20	ensure
278:5	4	-
278:8	29	old
278:13	40	this
278:19	4	=
278:22	40	this
279:3	19	end
280:3	4	/
280:6	48	(
280:7	2	other
280:12	56	:
280:15	12	as
280:19	40	this
280:23	49	)
280:24	56	:
280:27	12	as
280:31	40	this
280:37	45	virtual
281:5	3	/ Definition of division
282:3	19	end
283:3	4	*
283:6	48	(
283:7	2	other
283:12	56	:
283:15	12	as
283:19	40	this
283:23	49	)
283:24	56	:
283:27	12	as
283:31	40	this
283:37	45	virtual
284:5	3	/ Definition of multiplication
285:3	19	end
286:3	4	**
286:7	48	(
286:8	2	other
286:13	56	:
286:16	2	Numeric
286:23	49	)
286:24	56	:
286:27	12	as
286:31	40	this
286:37	45	virtual
287:5	3	/ Definition of power
288:3	19	end
289:1	34	require
290:3	40	this
290:9	4	=
290:12	40	this
290:18	4	*
290:21	2	one
290:26	3	/ Multiplication constituent 1
291:3	2	zero
291:9	4	=
291:12	40	this
291:18	4	*
291:21	2	zero
291:27	3	/ Multiplication constituent 2
292:3	40	this
292:9	4	=
292:12	40	this
292:18	4	+
292:21	2	zero
292:27	3	/ Addition constituent 1
293:3	2	one
293:8	4	=
293:11	2	one
293:16	4	+
293:19	2	zero
293:25	3	/ Addition constituent 2
294:3	40	this
294:9	4	=
294:12	40	this
294:18	4	**
294:22	2	one
294:27	3	/ Power constituent 1
295:3	2	one
295:8	4	=
295:11	40	this
295:17	4	**
295:21	2	zero
295:27	3	/ Power constituent 2
296:3	2	zero
296:9	4	=
296:12	40	this
296:18	4	-
296:21	40	this
296:27	3	/ Subtraction constituent 1
297:3	40	this
297:9	4	=
297:12	40	this
297:18	4	-
297:21	2	zero
297:27	3	/ Subtraction constituent 1
298:3	2	one
298:8	4	=
298:11	40	this
298:17	4	/
298:20	40	this
298:26	3	/ Division constituent
299:1	19	end
299:6	3	 Numeric
301:1	45	virtual
301:10	41	unit
301:16	2	Comparable
302:3	4	<
302:6	48	(
302:7	2	other
302:12	56	:
302:15	12	as
302:19	40	this
302:23	49	)
302:24	56	:
302:27	2	Boolean
302:36	45	virtual
303:3	3	 It looks we may rely on default equality test from Any ...
304:3	3	override = (other: as this): Boolean virtual
	end
306:3	31	pure
306:9	4	>
306:12	48	(
306:13	2	other
306:18	56	:
306:21	12	as
306:25	40	this
306:29	49	)
306:30	56	:
306:33	2	Boolean
306:42	4	=>
306:46	2	other
306:53	4	<
306:56	40	this
307:3	31	pure
307:9	4	<=
307:13	48	(
307:14	2	other
307:19	56	:
307:22	12	as
307:26	40	this
307:30	49	)
307:31	56	:
307:34	2	Boolean
307:43	4	=>
307:47	2	not
307:52	48	(
307:53	2	other
307:60	4	<
307:63	40	this
307:67	49	)
308:3	31	pure
308:9	4	>=
308:13	48	(
308:14	2	other
308:19	56	:
308:22	12	as
308:26	40	this
308:30	49	)
308:31	56	:
308:34	2	Boolean
308:43	4	=>
308:47	2	not
308:52	48	(
308:53	40	this
308:59	4	<
308:62	2	other
308:67	49	)
309:3	31	pure
309:9	2	max
309:14	48	(
309:15	2	other
309:20	56	:
309:23	12	as
309:27	40	this
309:31	49	)
309:32	56	:
309:35	12	as
309:39	40	this
309:45	4	=>
309:49	24	if
309:53	40	this
309:59	4	>
309:62	2	other
309:69	16	do
309:73	40	this
309:79	17	else
309:85	2	other
310:3	31	pure
310:9	2	min
310:14	48	(
310:15	2	other
310:20	56	:
310:23	12	as
310:27	40	this
310:31	49	)
310:32	56	:
310:35	12	as
310:39	40	this
310:45	4	=>
310:49	24	if
310:53	40	this
310:59	4	<
310:62	2	other
310:69	16	do
310:73	40	this
310:79	17	else
310:85	2	other
311:1	34	require
312:3	2	not
312:8	48	(
312:9	40	this
312:15	4	<
312:18	40	this
312:22	49	)
312:25	3	/ Irreflexive comparison
313:1	19	end
313:6	3	 Comparable
315:1	45	virtual
315:10	41	unit
315:16	2	Enumeration
315:29	21	extend
315:37	2	Comparable
316:3	2	succ
316:7	56	:
316:10	12	as
316:14	40	this
316:20	45	virtual
317:3	3	/ successor of the current object
318:3	20	ensure
319:5	35	return
319:13	4	>
319:16	40	this
320:3	19	end
321:3	2	pred
321:7	56	:
321:10	12	as
321:14	40	this
321:20	45	virtual
322:3	3	/ predecessor of the current object
323:3	20	ensure
324:5	35	return
324:13	4	<
324:16	40	this
325:3	19	end
326:3	2	first
326:8	56	:
326:11	12	as
326:15	40	this
326:21	45	virtual
327:3	3	/ first element of enumeration
328:3	2	last
328:7	56	:
328:10	12	as
328:14	40	this
328:20	45	virtual
329:3	3	/ last element of enumeration
330:3	2	count
330:8	56	:
330:11	2	Integer
330:20	45	virtual
331:3	3	/ number of elements in the enumeration
332:3	2	ord
332:6	56	:
332:9	2	Integer
332:18	45	virtual
333:3	3	/ order of the current object in the enumeration, order starts with f_i_r_s_t :-) 
334:3	20	ensure
335:5	35	return
335:13	4	>
335:16	5	0
336:3	19	end
337:1	34	require
338:3	2	succ
338:9	4	>
338:12	2	pred
339:3	2	count
339:10	4	>=
339:14	5	0
340:3	2	ord
340:8	4	>
340:11	2	pred
340:15	59	.
340:16	2	ord
341:3	2	ord
341:8	4	<
341:11	2	succ
341:15	59	.
341:16	2	ord
342:1	19	end
344:1	43	val
344:6	41	unit
344:12	2	Pointer
345:3	3	/ Unit Pointer allows to introduce address arithmetics in a safe way :-)
346:3	3	 WIP!!!
347:3	30	override
347:13	2	sizeof
347:19	56	:
347:22	2	Integer
347:31	16	do
348:5	35	return
348:13	2	Platform
348:21	59	.
348:22	2	PointerBitsCount
348:40	4	/
348:43	2	Platform
348:51	59	.
348:52	2	BitsInByteCount
349:3	19	end
350:3	2	write
350:10	48	(
350:11	2	b
350:12	56	:
350:15	2	Byte
350:19	49	)
350:22	23	foreign
351:3	2	write
351:10	48	(
351:11	2	ab
351:13	56	:
351:16	2	Array
351:23	52	[
351:24	2	Byte
351:28	53	]
351:29	49	)
351:32	23	foreign
352:3	2	read
352:7	56	:
352:10	2	Byte
352:16	23	foreign
353:3	2	read
353:7	56	:
353:10	2	Array
353:17	52	[
353:18	2	Byte
353:22	53	]
353:25	23	foreign
354:3	50	{
354:4	51	}
354:7	44	var
354:12	2	data
354:18	56	:
354:21	2	Bit
354:26	52	[
354:27	2	Platform
354:35	59	.
354:36	2	PointerBitsCount
354:52	53	]
355:3	26	init
355:9	48	(
355:10	2	address
355:17	56	:
355:20	2	Integer
355:27	49	)
356:3	34	require
357:5	2	address
357:14	4	>=
357:18	5	0
357:21	3	/ Pointer should be greater than zero
358:3	16	do
359:5	2	data
359:11	55	:=
359:15	2	address
359:22	59	.
359:23	2	data
360:3	19	end
361:3	50	{
361:4	51	}
361:7	2	validPointer
361:21	48	(
361:22	2	p
361:23	56	:
361:26	2	Pointer
361:33	49	)
361:34	56	:
361:37	2	Boolean
361:46	23	foreign
362:1	34	require
363:3	2	validPointer
363:17	48	(
363:18	40	this
363:22	49	)
364:1	19	end
364:6	3	 Pointer
366:1	43	val
366:6	41	unit
366:12	2	Cardinal
366:22	11	alias
366:29	2	uInt
366:35	21	extend
366:43	2	Cardinal
366:53	52	[
366:54	2	Platform
366:62	59	.
366:63	2	CardinalBitsCount
366:80	53	]
367:3	26	init
367:9	48	(
367:10	2	value
367:15	56	:
367:18	12	as
367:22	40	this
367:26	49	)
367:29	16	do
368:5	2	data
368:11	55	:=
368:15	2	value
368:20	59	.
368:21	2	data
369:3	19	end
370:3	26	init
370:9	16	do
371:5	3	/ Default init with zero
372:5	2	data
372:11	55	:=
372:15	2	Bit
372:20	52	[
372:21	2	Platform
372:29	59	.
372:30	2	CardinalBitsCount
372:47	53	]
373:3	19	end
374:1	19	end
374:6	3	 Cardinal
376:1	43	val
376:6	41	unit
376:12	2	Cardinal
376:22	11	alias
376:29	2	uInt
376:35	52	[
376:36	2	BitsNumber
376:46	56	:
376:49	2	Cardinal
376:57	53	]
376:60	21	extend
376:68	2	Numeric
376:75	57	,
376:78	2	Enumeration
377:3	3	 WIP!!!!
378:3	3	 the caveat how to distingush Integer.1 from Cardinal.1 - now Cardinal constants are not imported into Any deu to name clash!!! .... 
379:3	3	 Need to think more ...
380:3	3	 No need for cardinal so far ...
381:1	19	end
383:1	43	val
383:6	41	unit
383:12	2	Integer
383:21	21	extend
383:29	2	Integer
383:38	52	[
383:39	2	Platform
383:47	59	.
383:48	2	IntegerBitsCount
383:64	53	]
384:3	26	init
384:9	48	(
384:10	2	value
384:15	56	:
384:18	2	Integer
384:25	49	)
384:28	16	do
385:5	2	data
385:11	55	:=
385:15	2	value
385:20	59	.
385:21	2	data
386:3	19	end
387:3	26	init
387:9	16	do
388:5	3	/ Default init with zero
389:5	2	data
389:11	55	:=
389:15	2	Bit
389:20	52	[
389:21	2	Platform
389:29	59	.
389:30	2	IntegerBitsCount
389:46	53	]
390:3	19	end
391:1	19	end
391:6	3	 Integer
393:1	43	val
393:6	41	unit
393:12	2	Integer
393:21	52	[
393:22	2	BitsNumber
393:32	56	:
393:35	2	Integer
393:42	53	]
393:45	21	extend
393:53	2	Numeric
393:60	57	,
393:63	2	Enumeration
394:3	2	minInteger
394:15	27	is
394:19	4	-
394:22	48	(
394:23	5	2
394:26	4	**
394:30	48	(
394:31	2	BitsNumber
394:43	4	-
394:46	5	1
394:47	49	)
394:48	49	)
395:3	2	maxInteger
395:15	27	is
395:19	5	2
395:22	4	**
395:26	48	(
395:27	2	BitsNumber
395:39	4	-
395:42	5	1
395:43	49	)
395:46	4	-
395:49	5	1
396:3	15	const
396:10	3	 That is ordered set defined as range of all Integer constant values (objects) 
397:5	2	minInteger
397:17	58	..
397:21	2	maxInteger
398:3	19	end
399:3	30	override
399:13	2	one
399:18	27	is
399:22	5	1
400:3	30	override
400:13	2	zero
400:19	27	is
400:23	5	0
401:3	30	override
401:13	2	sizeof
401:19	56	:
401:22	2	Integer
401:31	27	is
401:35	2	BitsNumber
401:47	4	/
401:50	2	Platform
401:58	59	.
401:59	2	BitsInByteCount
402:3	30	override
402:13	31	pure
402:19	2	succ
402:23	56	:
402:26	12	as
402:30	40	this
402:36	4	=>
402:40	40	this
402:46	4	+
402:49	2	one
403:3	30	override
403:13	31	pure
403:19	2	pred
403:23	56	:
403:26	12	as
403:30	40	this
403:36	4	=>
403:40	40	this
403:46	4	-
403:49	2	one
404:3	30	override
404:13	2	first
404:20	27	is
404:24	2	minInteger
405:3	30	override
405:13	2	last
405:19	27	is
405:23	2	maxInteger
406:3	31	pure
406:9	2	count
406:14	56	:
406:17	2	Integer
406:26	4	=>
406:30	2	last
406:36	4	-
406:39	2	first
406:46	4	+
406:49	5	1
407:3	31	pure
407:9	2	ord
407:12	56	:
407:15	2	Integer
407:24	4	=>
407:28	40	this
407:34	4	-
407:37	2	minInteger
407:49	4	+
407:52	5	1
408:3	30	override
408:13	4	+
408:16	48	(
408:17	2	other
408:22	56	:
408:25	12	as
408:29	40	this
408:33	49	)
408:34	56	:
408:37	12	as
408:41	40	this
408:47	16	do
409:5	3	 Bit-level implementation of Integer addition
410:5	32	raise
410:12	8	Not implemented!!!
411:3	19	end
412:3	4	+
412:6	48	(
412:7	2	other
412:12	56	:
412:15	2	Real
412:19	49	)
412:20	56	:
412:23	12	as
412:27	40	this
412:33	16	do
413:5	35	return
413:13	40	this
413:19	4	+
413:22	2	other
413:27	59	.
413:28	2	toInteger
414:3	19	end
415:3	4	+
415:6	48	(
415:7	2	other
415:12	56	:
415:15	2	Real
415:19	49	)
415:20	56	:
415:23	2	LongInteger
415:36	16	do
416:5	35	return
416:13	40	this
416:19	4	+
416:22	2	other
416:27	59	.
416:28	2	toInteger
417:3	19	end
418:3	4	+
418:6	16	do
419:5	3	 Unary plus
420:3	19	end
421:3	4	++
421:7	16	do
422:5	40	this
422:11	4	+=
422:15	2	one
423:3	19	end
424:3	4	+=
424:7	48	(
424:8	2	other
424:13	56	:
424:16	12	as
424:20	40	this
424:24	49	)
424:27	16	do
425:5	3	 Bit-level implementation of Integer increment
426:5	32	raise
426:12	8	Not implemented!!!
427:3	19	end
428:3	4	+=
428:7	48	(
428:8	2	other
428:13	56	:
428:16	2	Real
428:20	49	)
428:23	16	do
429:5	40	this
429:11	4	+=
429:15	2	other
429:20	59	.
429:21	2	toInteger
430:3	19	end
431:3	4	--
431:7	16	do
432:5	40	this
432:11	4	-=
432:15	2	one
433:3	19	end
434:3	4	-=
434:7	48	(
434:8	2	other
434:13	56	:
434:16	12	as
434:20	40	this
434:24	49	)
434:27	16	do
435:5	3	 Bit-level implementation of Integer decrement
436:5	32	raise
436:12	8	Not implemented!!!
437:3	19	end
438:3	4	-=
438:7	48	(
438:8	2	other
438:13	56	:
438:16	2	Real
438:20	49	)
438:23	16	do
439:5	40	this
439:11	4	-=
439:15	2	other
439:20	59	.
439:21	2	toInteger
440:3	19	end
441:3	30	override
441:13	4	-
441:16	48	(
441:17	2	other
441:22	56	:
441:25	12	as
441:29	40	this
441:33	49	)
441:34	56	:
441:37	12	as
441:41	40	this
441:47	16	do
442:5	3	 Bit-level implementation of Integer subtraction
443:5	32	raise
443:12	8	Not implemented!!!
444:3	19	end
445:3	4	-
445:6	48	(
445:7	2	other
445:12	56	:
445:15	2	Real
445:19	49	)
445:20	56	:
445:23	12	as
445:27	40	this
445:33	16	do
446:5	35	return
446:13	40	this
446:19	4	-
446:22	2	other
446:27	59	.
446:28	2	toInteger
447:3	19	end
448:3	4	-
448:6	16	do
449:5	3	 Unary minus
450:5	35	return
450:13	5	0
450:16	4	-
450:19	40	this
451:3	19	end
452:3	30	override
452:13	4	/
452:16	48	(
452:17	2	other
452:22	56	:
452:25	12	as
452:29	40	this
452:33	49	)
452:34	56	:
452:37	12	as
452:41	40	this
452:47	16	do
453:5	3	 Bit-level implementation of Integer division
454:5	32	raise
454:12	8	Not implemented!!!
455:3	19	end
456:3	4	\
456:6	48	(
456:7	2	other
456:12	56	:
456:15	12	as
456:19	40	this
456:23	49	)
456:24	56	:
456:27	12	as
456:31	40	this
456:37	16	do
457:5	3	 Bit-level implementation of Integer division reminder
458:5	32	raise
458:12	8	Not implemented!!!
459:3	19	end
460:3	4	/
460:6	48	(
460:7	2	other
460:12	56	:
460:15	12	as
460:19	40	this
460:23	49	)
460:24	56	:
460:27	2	Real
460:33	16	do
461:5	3	 Bit-level implementation of precise division
462:5	32	raise
462:12	8	Not implemented!!!
463:3	19	end
464:3	4	/
464:6	48	(
464:7	2	other
464:12	56	:
464:15	2	Real
464:19	49	)
464:20	56	:
464:23	2	Real
464:29	16	do
465:5	3	 Bit-level implementation of precise division
466:5	32	raise
466:12	8	Not implemented!!!
467:3	19	end
468:3	30	override
468:13	4	*
468:16	48	(
468:17	2	other
468:22	56	:
468:25	12	as
468:29	40	this
468:33	49	)
468:34	56	:
468:37	12	as
468:41	40	this
468:47	16	do
469:5	3	 Bit-level implementation of Integer multiplication
470:5	32	raise
470:12	8	Not implemented!!!
471:3	19	end
472:3	4	*
472:6	48	(
472:7	2	other
472:12	56	:
472:15	2	Real
472:19	49	)
472:20	56	:
472:23	2	Real
472:29	16	do
473:5	35	return
473:13	2	other
473:20	4	*
473:23	40	this
474:3	19	end
475:3	30	override
475:13	4	**
475:17	48	(
475:18	2	other
475:23	56	:
475:26	12	as
475:30	40	this
475:34	49	)
475:35	56	:
475:38	12	as
475:42	40	this
475:48	16	do
476:5	3	 Bit-level implementation of Integer rasing to power
477:5	32	raise
477:12	8	Not implemented!!!
478:3	19	end
479:3	30	override
479:13	4	<
479:16	48	(
479:17	2	other
479:22	56	:
479:25	12	as
479:29	40	this
479:33	49	)
479:34	56	:
479:37	2	Boolean
479:46	16	do
480:5	3	 Bit-level implementation of Integer less
481:5	32	raise
481:12	8	Not implemented!!!
482:3	19	end
483:3	30	override
483:13	4	=
483:16	48	(
483:17	2	other
483:22	56	:
483:25	12	as
483:29	40	this
483:33	49	)
483:34	56	:
483:37	2	Boolean
483:46	16	do
484:5	3	 Bit-level implementation of Inetegr equal
485:5	35	return
485:13	2	data
485:19	4	=
485:22	2	other
485:27	59	.
485:28	2	data
486:3	19	end
487:3	30	override
487:13	55	:=
487:17	48	(
487:18	2	other
487:23	56	:
487:26	43	val
487:31	2	Integer
487:38	49	)
487:41	16	do
488:5	26	init
488:11	48	(
488:12	2	other
488:17	49	)
489:3	19	end
490:3	30	override
490:13	55	:=
490:17	48	(
490:18	2	other
490:23	56	:
490:26	33	ref
490:31	2	Integer
490:38	49	)
490:41	16	do
491:5	26	init
491:11	48	(
491:12	2	other
491:17	49	)
492:3	19	end
493:3	55	:=
493:7	48	(
493:8	2	other
493:13	56	:
493:16	2	Real
493:20	49	)
493:23	16	do
494:5	3	 Bit-level implementation of Real assignment
495:5	32	raise
495:12	8	Not implemented!!!
496:3	19	end
497:3	55	:=
497:7	48	(
497:8	2	other
497:13	56	:
497:16	2	Character
497:25	49	)
497:28	16	do
498:5	3	 Bit-level implementation of Chracter assignment
499:3	32	raise
499:10	8	Not implemented!!!
500:5	24	if
500:9	2	data
500:13	59	.
500:14	2	sizeof
500:22	4	=
500:25	2	other
500:30	59	.
500:31	2	data
500:35	59	.
500:36	2	sizeof
500:44	16	do
501:7	2	data
501:13	55	:=
501:17	2	other
501:22	59	.
501:23	2	data
501:29	3	 Size of data is different!!!
502:5	17	else
503:5	19	end
504:3	19	end
505:3	31	pure
505:9	2	toCharacter
505:20	56	:
505:23	2	Character
506:3	34	require
507:5	40	this
507:11	25	in
507:15	5	0
507:18	58	..
507:22	5	2
507:25	4	**
507:29	2	Platform
507:37	59	.
507:38	2	CharacterBitsCount
507:58	3	/ containsChacraterCode: 
508:3	16	do
509:5	35	return
509:13	28	new
509:18	2	Character
509:27	59	.
509:28	26	init
509:34	48	(
509:35	2	data
509:39	59	.
509:40	2	getLowBits
509:52	48	(
509:53	2	Platform
509:61	59	.
509:62	2	CharacterBitsCount
509:80	49	)
509:81	49	)
510:3	19	end
511:3	26	init
511:9	48	(
511:10	2	value
511:15	56	:
511:18	2	Integer
511:25	49	)
511:28	16	do
512:5	2	data
512:11	55	:=
512:15	2	value
512:20	59	.
512:21	2	data
513:3	19	end
514:3	26	init
514:9	16	do
515:5	3	/ Default init
516:5	2	data
516:11	55	:=
516:15	2	Bit
516:20	52	[
516:21	2	BitsNumber
516:31	53	]
517:3	19	end
518:3	50	{
518:4	51	}
518:7	44	var
518:12	2	data
518:16	56	:
518:19	2	Bit
518:24	52	[
518:25	2	BitsNumber
518:35	53	]
519:1	34	require
520:3	2	BitsNumber
520:15	4	>
520:18	5	0
520:21	3	/ Number of bits in Integer must be greater than zero!
521:1	19	end
521:6	3	 Integer
523:1	43	val
523:6	41	unit
523:12	2	Byte
524:3	3	 WIP - to be fully implemented
525:3	26	init
525:9	48	(
525:10	2	value
525:15	56	:
525:18	2	Byte
525:22	49	)
525:25	16	do
526:5	2	data
526:11	55	:=
526:15	2	value
526:20	59	.
526:21	2	data
527:3	19	end
528:3	26	init
528:9	16	do
529:5	3	/ Default init
530:5	2	data
530:11	55	:=
530:15	2	Bit
530:20	52	[
530:21	2	Platform
530:29	59	.
530:30	2	BitsInByteCount
530:45	53	]
531:3	19	end
532:3	50	{
532:4	51	}
532:7	44	var
532:12	2	data
532:16	56	:
532:19	2	Bit
532:24	52	[
532:25	2	Platform
532:33	59	.
532:34	2	BitsInByteCount
532:49	53	]
533:1	19	end
535:1	45	virtual
535:10	41	unit
535:16	2	Rational
535:26	21	extend
535:34	2	Numeric
535:41	57	,
535:44	2	Comparable
536:3	44	var
536:8	2	numerator
536:17	56	:
536:20	2	Integer
537:3	44	var
537:8	2	denominator
537:19	56	:
537:22	2	Integer
538:3	31	pure
538:9	2	toReal
538:15	56	:
538:18	2	Real
538:24	4	=>
538:28	2	numerator
538:39	4	/
538:42	2	denominator
539:3	3	 TBD!!!
540:1	34	require
541:3	2	denominator
541:16	4	/=
541:20	5	0
541:23	3	/ denominator must not be zero
542:1	19	end
544:1	45	virtual
544:10	41	unit
544:16	2	Fixed
544:23	21	extend
544:31	2	Numeric
544:38	57	,
544:41	2	Comparable
545:3	44	var
545:8	2	value
545:13	56	:
545:16	2	Integer
546:3	44	var
546:8	2	scaleFactor
546:19	56	:
546:22	2	Integer
546:31	3	 if scaleFactor is negative do scale is 1/-scaleFactor otherwise scaleFactor is scaleFactor :-)
547:3	31	pure
547:9	2	toReal
547:15	56	:
547:18	2	Real
547:24	4	=>
547:28	24	if
547:32	2	scaleFactor
547:45	4	<
547:48	5	0
547:51	16	do
547:55	2	value
547:62	4	/
547:65	4	-
547:68	2	scaleFactor
547:81	17	else
547:87	2	value
547:94	4	*
547:97	2	scaleFactor
548:3	3	 TBD!!!
549:1	19	end
551:1	45	virtual
551:10	41	unit
551:16	2	Float
551:23	52	[
551:24	2	nBits
551:29	56	:
551:32	2	Integer
551:39	53	]
551:42	21	extend
551:50	2	Numeric
551:57	57	,
551:60	2	Comparable
552:3	2	toReal
552:9	56	:
552:12	2	Real
552:18	45	virtual
553:3	3	 TBD!!!
554:1	19	end
556:1	43	val
556:6	41	unit
556:12	2	Real
556:18	21	extend
556:26	2	Float
556:33	52	[
556:34	2	Platform
556:42	59	.
556:43	2	RealBitsCount
556:56	53	]
557:3	2	minReal
557:10	56	:
557:13	2	Real
557:19	27	is
557:23	4	-
557:24	2	RealMaxMantissa
557:41	4	*
557:44	5	10
557:48	4	**
557:52	2	RealMaxOrder
558:3	2	maxReal
558:10	56	:
558:13	2	Real
558:19	27	is
558:23	2	RealMaxMantissa
558:40	4	*
558:43	5	10
558:47	4	**
558:51	2	RealMaxOrder
559:3	2	epsilon
559:10	56	:
559:13	2	Real
559:19	27	is
559:23	2	RealMinMantissa
559:40	4	*
559:43	5	10
559:47	4	**
559:51	4	-
559:52	2	RealMaxOrder
560:3	50	{
560:4	51	}
560:7	2	RealMaxMantissa
560:24	27	is
560:28	5	2
560:31	4	**
560:35	2	Platform
560:43	59	.
560:44	2	RealMantissaBitsCount
560:67	4	-
560:70	5	1
561:3	50	{
561:4	51	}
561:7	2	RealMinMantissa
561:24	27	is
561:28	6	0000001
561:38	3	/ TBD
562:3	50	{
562:4	51	}
562:7	2	RealMaxOrder
562:21	27	is
562:25	5	2
562:28	4	**
562:32	2	Platform
562:40	59	.
562:41	2	RealOderBitsCount
562:60	4	-
562:63	5	1
563:3	15	const
564:5	50	{
564:6	2	minReal
564:15	4	+
564:18	2	epsilon
564:25	51	}
564:28	4	<=
564:32	2	maxReal
565:3	19	end
566:3	30	override
566:13	2	one
566:18	27	is
566:22	6	10
567:3	30	override
567:13	2	zero
567:19	27	is
567:23	6	00
568:3	30	override
568:13	2	sizeof
568:19	56	:
568:22	2	Integer
568:31	27	is
568:35	2	Platform
568:43	59	.
568:44	2	RealBitsCount
568:59	4	/
568:62	2	Platform
568:70	59	.
568:71	2	BitsInByteCount
569:3	30	override
569:13	4	+
569:16	48	(
569:17	2	other
569:22	56	:
569:25	12	as
569:29	40	this
569:33	49	)
569:34	56	:
569:37	12	as
569:41	40	this
569:47	16	do
570:5	3	 Bit-level implementation
571:5	32	raise
571:12	8	Not implemented!!!
572:3	19	end
573:3	4	+
573:6	11	alias
573:13	2	plus
573:17	48	(
573:18	2	other
573:23	56	:
573:26	2	Integer
573:33	49	)
573:34	56	:
573:37	12	as
573:41	40	this
573:47	16	do
574:5	3	 Bit-level implementation
575:5	32	raise
575:12	8	Not implemented!!!
576:3	19	end
577:3	4	+
577:6	11	alias
577:13	2	plus
577:19	16	do
578:5	3	 Unary plus
579:3	19	end
580:3	30	override
580:13	4	-
580:16	48	(
580:17	2	other
580:22	56	:
580:25	12	as
580:29	40	this
580:33	49	)
580:34	56	:
580:37	12	as
580:41	40	this
580:47	16	do
581:5	3	 Bit-level implementation
582:5	32	raise
582:12	8	Not implemented!!!
583:3	19	end
584:3	4	-
584:6	11	alias
584:13	2	minus
584:20	48	(
584:21	2	other
584:26	56	:
584:29	2	Integer
584:36	49	)
584:37	56	:
584:40	12	as
584:44	40	this
584:50	16	do
585:5	3	 Bit-level implementation
586:5	32	raise
586:12	8	Not implemented!!!
587:3	19	end
588:3	4	-
588:6	11	alias
588:13	2	minus
588:20	16	do
589:5	3	 Unary minus 
590:5	3	 Bit-level implemenation
591:5	32	raise
591:12	8	Not implemented!!!
592:3	19	end
593:3	30	override
593:13	4	/
593:16	48	(
593:17	2	other
593:22	56	:
593:25	12	as
593:29	40	this
593:33	49	)
593:34	56	:
593:37	12	as
593:41	40	this
593:47	16	do
594:5	3	 Bit-level implementation
595:5	32	raise
595:12	8	Not implemented!!!
596:3	19	end
597:3	4	/
597:6	48	(
597:7	2	other
597:12	56	:
597:15	2	Integer
597:22	49	)
597:23	56	:
597:26	12	as
597:30	40	this
597:36	16	do
598:5	3	 Bit-level implementation
599:5	32	raise
599:12	8	Not implemented!!!
600:3	19	end
601:3	30	override
601:13	4	*
601:16	48	(
601:17	2	other
601:22	56	:
601:25	12	as
601:29	40	this
601:33	49	)
601:34	56	:
601:37	12	as
601:41	40	this
601:47	16	do
602:5	3	 Bit-level implementation
603:5	32	raise
603:12	8	Not implemented!!!
604:3	19	end
605:3	4	*
605:6	48	(
605:7	2	other
605:12	56	:
605:15	2	Integer
605:22	49	)
605:23	56	:
605:26	12	as
605:30	40	this
605:36	16	do
606:5	3	 Bit-level implementation
607:5	32	raise
607:12	8	Not implemented!!!
608:3	19	end
609:3	30	override
609:13	4	**
609:17	48	(
609:18	2	other
609:23	56	:
609:26	12	as
609:30	40	this
609:34	49	)
609:35	56	:
609:38	12	as
609:42	40	this
609:48	16	do
610:5	3	 Bit-level implementation
611:5	32	raise
611:12	8	Not implemented!!!
612:3	19	end
613:3	30	override
613:13	4	**
613:17	48	(
613:18	2	other
613:23	56	:
613:26	2	Integer
613:33	49	)
613:34	56	:
613:37	12	as
613:41	40	this
613:47	16	do
614:5	3	 Bit-level implementation
615:5	32	raise
615:12	8	Not implemented!!!
616:3	19	end
617:3	30	override
617:13	4	<
617:16	48	(
617:17	2	other
617:22	56	:
617:25	12	as
617:29	40	this
617:33	49	)
617:34	56	:
617:37	2	Boolean
617:46	16	do
618:5	3	 Bit-level implementation
619:5	32	raise
619:12	8	Not implemented!!!
620:3	19	end
621:3	30	override
621:13	4	<
621:16	48	(
621:17	2	other
621:22	56	:
621:25	2	Integer
621:32	49	)
621:33	56	:
621:36	2	Boolean
621:45	16	do
622:5	3	 Bit-level implementation
623:5	32	raise
623:12	8	Not implemented!!!
624:3	19	end
625:3	30	override
625:13	4	=
625:16	48	(
625:17	2	other
625:22	56	:
625:25	12	as
625:29	40	this
625:33	49	)
625:34	56	:
625:37	2	Boolean
625:46	16	do
626:5	3	 Bit-level implementation
627:5	32	raise
627:12	8	Not implemented!!!
628:3	19	end
629:3	30	override
629:13	4	=
629:16	48	(
629:17	2	other
629:22	56	:
629:25	2	Integer
629:32	49	)
629:33	56	:
629:36	2	Boolean
629:45	16	do
630:5	3	 Bit-level implementation
631:5	32	raise
631:12	8	Not implemented!!!
632:3	19	end
633:3	30	override
633:13	55	:=
633:17	48	(
633:18	2	other
633:23	56	:
633:26	12	as
633:30	40	this
633:34	49	)
633:37	16	do
634:5	3	 Bit-level implementation
635:5	2	data
635:11	55	:=
635:15	2	other
635:20	59	.
635:21	2	data
636:3	19	end
637:3	55	:=
637:7	48	(
637:8	2	other
637:13	56	:
637:16	2	Integer
637:23	49	)
637:26	16	do
638:5	3	 Bit-level implementation
639:5	32	raise
639:12	8	Not implemented!!!
640:3	19	end
641:3	2	toInteger
641:12	56	:
641:15	2	Integer
641:24	16	do
642:5	3	 Bit-level implementation
643:5	32	raise
643:12	8	Not implemented!!!
644:3	19	end
645:3	26	init
645:9	48	(
645:10	2	value
645:15	56	:
645:18	43	val
645:23	2	Real
645:27	49	)
645:30	16	do
646:5	2	data
646:11	55	:=
646:15	2	value
646:20	59	.
646:21	2	data
647:3	19	end
648:3	26	init
648:9	16	do
649:5	2	data
649:11	55	:=
649:15	2	Bit
649:20	52	[
649:21	2	Platform
649:29	59	.
649:30	2	RealBitsCount
649:43	53	]
650:3	19	end
651:3	50	{
651:4	51	}
651:7	44	var
651:12	2	data
651:18	56	:
651:21	2	Bit
651:26	52	[
651:27	2	Platform
651:35	59	.
651:36	2	RealBitsCount
651:49	53	]
652:1	19	end
652:6	3	 Real
654:1	43	val
654:6	41	unit
654:12	2	Character
654:23	11	alias
654:30	2	Char
654:36	21	extend
654:44	2	Enumeration
655:3	2	minCharacter
655:17	27	is
655:21	5	0
655:23	59	.
655:23	2	ToCharacter
656:3	2	maxCharacter
656:17	27	is
656:21	48	(
656:22	5	2
656:25	4	**
656:29	2	Platform
656:37	59	.
656:38	2	CharacterBitsCount
656:58	4	-
656:61	5	1
656:62	49	)
656:63	59	.
656:64	2	ToCharacter
657:3	15	const
657:10	3	 The set of all constant objects of unit type Character
658:5	2	minCharacter
658:19	58	..
658:23	2	maxCharacter
659:3	19	end
660:3	30	override
660:13	31	pure
660:19	2	succ
660:23	56	:
660:26	12	as
660:30	40	this
660:36	4	=>
660:40	48	(
660:41	40	this
660:45	59	.
660:46	2	toInteger
660:57	4	+
660:60	2	one
660:63	49	)
660:64	59	.
660:65	2	toCharacter
661:3	30	override
661:13	31	pure
661:19	2	pred
661:23	56	:
661:26	12	as
661:30	40	this
661:36	4	=>
661:40	48	(
661:41	40	this
661:45	59	.
661:46	2	toInteger
661:57	4	-
661:60	2	one
661:63	49	)
661:64	59	.
661:65	2	ToCharacter
662:3	30	override
662:13	2	first
662:20	27	is
662:24	2	minCharacter
663:3	30	override
663:13	2	last
663:19	27	is
663:23	2	maxCharacter
664:3	2	count
664:10	27	is
664:14	5	2
664:17	4	**
664:21	2	Platform
664:29	59	.
664:30	2	CharacterBitsCount
665:3	2	ord
665:6	56	:
665:9	2	Integer
665:18	4	=>
665:22	2	toInteger
666:3	30	override
666:13	4	<
666:16	48	(
666:17	2	other
666:22	56	:
666:25	12	as
666:29	40	this
666:33	49	)
666:34	56	:
666:37	2	Boolean
666:46	16	do
667:5	3	 Bit-level implementation
668:5	32	raise
668:12	8	Not implemented!!!
669:3	19	end
670:3	30	override
670:13	2	sizeof
670:19	56	:
670:22	2	Integer
670:31	27	is
670:35	2	Platform
670:43	59	.
670:44	2	CharacterBitsCount
670:64	4	/
670:67	2	Platform
670:75	59	.
670:76	2	BitsInByteCount
671:3	31	pure
671:9	2	toInteger
671:18	56	:
671:21	2	Integer
671:30	16	do
672:5	35	return
672:13	28	new
672:18	2	Integer
672:25	59	.
672:26	26	init
672:32	48	(
672:33	2	data
672:37	59	.
672:38	2	ToInteger
672:47	49	)
673:3	20	ensure
674:5	35	return
674:13	25	in
674:17	35	return
674:23	59	.
674:24	2	minInteger
674:36	58	..
674:40	35	return
674:46	59	.
674:47	2	maxInteger
675:3	19	end
676:3	55	:=
676:7	48	(
676:8	2	other
676:13	56	:
676:16	2	Integer
676:23	49	)
677:3	34	require
678:5	2	other
678:12	25	in
678:16	5	0
678:19	58	..
678:23	5	2
678:26	4	**
678:30	2	Platform
678:38	59	.
678:39	2	CharacterBitsCount
678:59	4	-
678:62	5	1
678:65	3	/ Invalid character code		
679:3	16	do
680:5	2	data
680:11	55	:=
680:15	2	other
681:3	19	end
682:3	26	init
682:9	48	(
682:10	2	value
682:15	56	:
682:18	43	val
682:23	2	Character
682:32	49	)
682:35	16	do
683:5	2	data
683:11	55	:=
683:15	2	value
683:20	59	.
683:21	2	data
684:3	19	end
685:3	26	init
685:9	16	do
686:5	2	data
686:11	55	:=
686:15	2	Bit
686:20	52	[
686:21	2	Platform
686:29	59	.
686:30	2	CharacterBitsCount
686:48	53	]
687:3	19	end
688:3	50	{
688:4	51	}
688:7	44	var
688:12	2	data
688:18	56	:
688:21	2	Bit
688:26	52	[
688:27	2	Platform
688:35	59	.
688:36	2	CharacterBitsCount
688:54	53	]
689:1	19	end
689:6	3	 Character
691:1	43	val
691:6	41	unit
691:12	2	Boolean
691:21	11	alias
691:28	2	Bool
691:34	21	extend
691:42	2	Enumeration
692:3	50	{
692:4	40	this
692:8	51	}
692:11	2	one
692:16	27	is
692:20	5	1
693:3	50	{
693:4	40	this
693:8	51	}
693:11	2	zero
693:17	27	is
693:21	5	0
694:3	15	const
694:10	3	 That is ordered set of two constant object of type Boolean
695:5	2	false
695:10	59	.
695:11	26	init
695:17	48	(
695:18	2	zero
695:22	49	)
695:23	57	,
695:26	2	true
695:30	59	.
695:31	26	init
695:37	48	(
695:38	2	one
695:41	49	)
696:3	19	end
698:3	30	override
698:13	31	pure
698:19	4	<
698:22	48	(
698:23	2	other
698:28	56	:
698:31	12	as
698:35	40	this
698:39	49	)
698:40	56	:
698:43	2	Boolean
698:52	4	=>
698:56	40	this
698:60	59	.
698:61	2	data
698:67	4	<
698:70	2	other
698:75	59	.
698:76	2	data
699:3	30	override
699:13	31	pure
699:19	4	=
699:22	48	(
699:23	2	other
699:28	56	:
699:31	12	as
699:35	40	this
699:39	49	)
699:40	56	:
699:43	2	Boolean
699:52	4	=>
699:56	40	this
699:60	59	.
699:61	2	data
699:67	4	=
699:70	2	other
699:75	59	.
699:76	2	data
700:3	30	override
700:13	31	pure
700:19	2	succ
700:23	56	:
700:26	12	as
700:30	40	this
700:36	4	=>
700:40	24	if
700:44	40	this
700:50	16	do
700:54	2	false
700:61	17	else
700:67	2	true
701:3	30	override
701:13	31	pure
701:19	2	pred
701:23	56	:
701:26	12	as
701:30	40	this
701:36	4	=>
701:40	24	if
701:44	40	this
701:50	16	do
701:54	2	false
701:61	17	else
701:67	2	true
702:3	30	override
702:13	2	first
702:20	27	is
702:24	2	false
703:3	30	override
703:13	2	last
703:19	27	is
703:23	2	true
704:3	2	count
704:10	27	is
704:14	5	2
705:3	31	pure
705:9	2	ord
705:12	56	:
705:15	2	Integer
705:24	4	=>
705:28	24	if
705:32	40	this
705:38	16	do
705:42	2	one
705:47	17	else
705:53	2	zero
706:3	30	override
706:13	2	sizeof
706:19	56	:
706:22	2	Integer
706:31	27	is
706:35	2	Platform
706:43	59	.
706:44	2	BooleanBitsCount
706:62	4	/
706:65	2	Platform
706:73	59	.
706:74	2	BitsInByteCount
707:3	31	pure
707:9	4	&
707:12	11	alias
707:19	2	and
707:24	48	(
707:25	2	other
707:30	56	:
707:33	12	as
707:37	40	this
707:41	49	)
707:42	56	:
707:45	2	Boolean
707:54	4	=>
707:58	24	if
707:62	40	this
707:68	16	do
707:72	24	if
707:76	2	other
707:83	16	do
707:87	2	true
707:93	17	else
707:99	2	false
707:106	17	else
707:112	2	false
708:5	3	 00 -> 0
709:5	3	 01 -> 0
710:5	3	 10 -> 0
711:5	3	 11 -> 1
712:3	31	pure
712:9	4	|
712:12	11	alias
712:19	2	or
712:23	48	(
712:24	2	other
712:29	56	:
712:32	12	as
712:36	40	this
712:40	49	)
712:41	56	:
712:44	2	Boolean
712:53	4	=>
712:57	24	if
712:61	40	this
712:67	4	=
712:70	2	false
712:77	16	do
712:81	24	if
712:85	2	other
712:92	16	do
712:96	2	true
712:102	17	else
712:108	2	false
712:115	17	else
712:121	2	true
713:5	3	 00 -> 0
714:5	3	 01 -> 1
715:5	3	 10 -> 1
716:5	3	 11 -> 1
717:3	31	pure
717:9	4	&&
717:13	11	alias
717:20	2	and
717:25	2	then
717:31	48	(
717:32	2	other
717:37	56	:
717:40	12	as
717:44	40	this
717:48	49	)
717:49	56	:
717:52	2	Boolean
717:61	4	=>
717:65	24	if
717:69	2	not
717:74	40	this
717:80	16	do
717:84	2	false
717:91	18	elsif
717:98	2	not
717:103	2	other
717:110	16	do
717:114	2	false
717:121	17	else
717:127	2	true
718:3	31	pure
718:9	4	||
718:13	11	alias
718:20	2	or
718:24	17	else
718:30	48	(
718:31	2	other
718:36	56	:
718:39	12	as
718:43	40	this
718:47	49	)
718:48	56	:
718:51	2	Boolean
718:60	4	=>
718:64	24	if
718:68	40	this
718:74	16	do
718:78	2	true
718:84	18	elsif
718:91	2	other
718:98	16	do
718:102	2	true
718:108	17	else
718:114	2	false
719:3	31	pure
719:9	4	^
719:12	11	alias
719:19	2	xor
719:24	48	(
719:25	2	other
719:30	56	:
719:33	12	as
719:37	40	this
719:41	49	)
719:42	56	:
719:45	2	Boolean
719:54	4	=>
719:58	24	if
719:62	40	this
719:68	16	do
719:72	24	if
719:76	2	other
719:83	16	do
719:87	2	false
719:94	17	else
719:100	2	true
719:106	17	else
719:112	24	if
719:116	2	other
719:123	16	do
719:127	2	true
719:133	17	else
719:139	2	false
720:5	3	 00 -> 0
721:5	3	 01 -> 1
722:5	3	 10 -> 1
723:5	3	 11 -> 0
724:3	31	pure
724:9	4	->
724:13	11	alias
724:20	2	implies
724:29	48	(
724:30	2	other
724:35	56	:
724:38	12	as
724:42	40	this
724:46	49	)
724:47	56	:
724:50	2	Boolean
724:59	4	=>
724:63	2	not
724:68	40	this
724:74	2	or
724:78	2	other
725:3	31	pure
725:9	54	~
725:12	11	alias
725:19	2	not
725:24	56	:
725:27	2	Boolean
725:36	4	=>
725:40	24	if
725:44	40	this
725:50	16	do
725:54	2	false
725:61	17	else
725:67	2	true
726:3	31	pure
726:9	2	toInteger
726:18	56	:
726:21	2	Integer
726:30	4	=>
726:34	24	if
726:38	40	this
726:44	16	do
726:48	2	one
726:53	17	else
726:59	2	zero
727:3	26	init
727:9	48	(
727:10	2	value
727:15	56	:
727:18	43	val
727:23	2	Boolean
727:30	49	)
727:33	16	do
728:5	2	data
728:11	55	:=
728:15	2	value
728:20	59	.
728:21	2	data
729:3	19	end
730:3	26	init
730:9	16	do
731:5	2	data
731:11	55	:=
731:15	5	0xb
732:3	19	end
733:3	50	{
733:4	51	}
733:7	26	init
733:13	48	(
733:14	2	value
733:19	56	:
733:22	2	Integer
733:29	49	)
734:3	34	require
735:5	2	value
735:12	25	in
735:16	2	zero
735:20	58	..
735:22	2	one
735:27	3	/ Valid Integer value
736:3	16	do
737:5	2	data
737:11	55	:=
737:15	2	value
738:3	19	end
739:3	50	{
739:4	51	}
739:7	44	var
739:12	2	data
739:16	56	:
739:19	2	Bit
739:24	52	[
739:25	2	Platform
739:33	59	.
739:34	2	BooleanBitsCount
739:50	53	]
740:1	34	require
741:3	40	this
741:9	2	and
741:14	40	this
741:20	4	=
741:23	40	this
741:29	3	/ idempotence of 'and'
742:3	40	this
742:9	2	or
742:13	40	this
742:19	4	=
742:22	40	this
742:28	3	/ idempotence of 'or'
743:3	40	this
743:9	2	and
743:14	2	not
743:19	40	this
743:25	4	=
743:28	2	false
743:35	3	/ complementation
744:3	40	this
744:9	2	or
744:13	2	not
744:18	40	this
744:24	4	=
744:27	2	true
744:33	3	/ complementation
745:1	19	end
745:6	3	 Boolean
747:1	45	virtual
747:10	41	unit
747:16	2	AString
747:25	21	extend
747:33	2	Comparable
748:3	3	/ virtualion of String
749:1	19	end
751:1	41	unit
751:7	2	String
751:15	52	[
751:16	2	N
751:17	56	:
751:18	2	Integer
751:25	53	]
751:28	21	extend
751:36	2	AString
751:43	57	,
751:46	2	Array
751:53	52	[
751:54	2	Character
751:63	57	,
751:66	2	N
751:67	53	]
752:3	3	/ String with fixed length
753:3	15	const
754:5	50	{
754:6	2	Character
754:15	59	.
754:16	2	minCharacter
754:30	4	|
754:31	58	..
754:35	2	Character
754:44	59	.
754:45	2	maxCharacter
754:57	51	}
754:58	2	N
755:5	3	 "" .. "Character*"
756:3	19	end
757:1	19	end
759:1	41	unit
759:7	2	String
759:15	21	extend
759:23	2	AString
760:3	15	const
761:5	50	{
761:6	2	Character
761:15	59	.
761:16	2	minCharacter
761:30	4	|
761:31	58	..
761:35	2	Character
761:44	59	.
761:45	2	maxCharacter
761:57	51	}
761:58	5	0
761:59	4	+
762:5	3	 "" .. "Character*"
763:3	19	end
764:3	3	/ Variable length String
765:3	30	override
765:13	4	<
765:16	48	(
765:17	2	other
765:22	56	:
765:25	12	as
765:29	40	this
765:33	49	)
765:34	56	:
765:37	2	Boolean
765:46	16	do
766:5	24	if
766:9	40	this
766:15	4	=
766:18	2	other
766:25	16	do
767:7	35	return
767:15	2	false
768:5	19	end
769:5	3	 Check the content
770:5	47	while
770:12	2	pos
770:17	25	in
770:21	5	1
770:23	58	..
770:24	2	count
770:31	16	do
771:7	3	 TODO WIP
772:7	32	raise
772:14	8	Not implemented!!!
773:5	19	end
774:5	35	return
774:13	2	false
775:3	19	end
776:3	30	override
776:13	4	=
776:16	48	(
776:17	2	other
776:22	56	:
776:25	12	as
776:29	40	this
776:33	49	)
776:34	56	:
776:37	2	Boolean
776:46	16	do
777:5	24	if
777:9	40	this
777:13	59	.
777:14	2	data
777:20	4	=
777:23	2	other
777:28	59	.
777:29	2	data
777:35	16	do
778:7	35	return
778:15	2	true
779:5	19	end
780:3	32	raise
780:10	8	Not implemented!!!
781:5	3	 Check the content to code !!! WIP
782:5	35	return
782:13	2	true
783:3	19	end
785:3	31	pure
785:9	2	count
785:14	56	:
785:17	2	Integer
785:26	4	=>
785:30	2	data
785:34	59	.
785:35	2	count
787:3	31	pure
787:9	48	(
787:10	49	)
787:13	48	(
787:14	2	pos
787:17	56	:
787:20	2	Integer
787:27	49	)
787:28	56	:
787:31	2	Character
788:5	3	/ Get character at position pos
789:3	34	require
790:5	5	1
790:8	4	<=
790:12	2	pos
790:17	2	and
790:22	2	then
790:28	2	pos
790:33	4	<=
790:37	2	count
790:44	3	/ Valid element index
791:3	16	do
792:5	35	return
792:13	2	data
792:19	48	(
792:20	2	pos
792:23	49	)
793:3	19	end
794:3	48	(
794:4	49	)
794:7	48	(
794:8	2	pos
794:11	56	:
794:14	2	Integer
794:25	2	value
794:30	56	:
794:33	2	G
794:34	49	)
795:5	3	/ Set array element at position pos with value
796:3	34	require
797:5	5	1
797:8	4	<=
797:12	2	pos
797:17	2	and
797:22	2	then
797:28	2	pos
797:33	4	<=
797:37	2	count
797:44	3	/ Valid element index 
798:3	16	do
799:5	2	data
799:11	48	(
799:12	2	pos
799:15	49	)
799:18	55	:=
799:22	2	value
800:3	19	end
801:3	48	(
801:4	49	)
801:7	48	(
801:8	2	from
801:12	57	,
801:15	2	to
801:17	56	:
801:20	2	Integer
801:27	49	)
801:28	56	:
801:31	12	as
801:35	40	this
802:3	3	 substring
803:3	34	require
804:5	2	from
804:11	4	<=
804:15	2	to
804:19	3	/ Valid charters' indices range
805:5	5	1
805:8	4	<=
805:12	2	from
805:18	4	<=
805:22	2	count
805:29	3	/
806:5	5	1
806:8	4	<=
806:12	2	to
806:16	4	<=
806:20	2	count
806:27	3	/
807:3	16	do
808:5	3	 WIP to implement
809:5	32	raise
809:12	8	Not implemented!!!
810:3	19	end
811:3	4	+
811:6	48	(
811:7	2	other
811:12	56	:
811:15	12	as
811:19	40	this
811:23	49	)
811:24	56	:
811:27	12	as
811:31	40	this
812:3	16	do
813:5	3	 WIP to implement
814:5	32	raise
814:12	8	Not implemented!!!
815:3	20	ensure
816:5	35	return
816:11	59	.
816:12	2	count
816:19	4	=
816:22	40	this
816:26	59	.
816:27	2	count
816:34	4	+
816:37	2	other
816:42	59	.
816:43	2	count
816:50	3	/ Valid concatenated string length
817:3	19	end
818:3	26	init
818:9	16	do
819:5	2	data
819:11	55	:=
819:15	2	Array
819:22	52	[
819:23	2	Character
819:32	53	]
819:35	48	(
819:36	5	1
819:37	57	,
819:40	5	0
819:41	49	)
820:3	19	end
821:3	26	init
821:9	48	(
821:10	2	other
821:15	56	:
821:18	12	as
821:22	40	this
821:26	49	)
821:29	16	do
822:5	2	data
822:11	55	:=
822:15	2	other
822:20	59	.
822:21	2	data
823:3	19	end
824:3	50	{
824:4	51	}
824:7	44	var
824:12	2	data
824:16	56	:
824:19	2	Array
824:26	52	[
824:27	2	Character
824:36	53	]
824:39	3	 Dynamic empty array of characters
825:1	19	end
825:6	3	 String
827:1	45	virtual
827:10	41	unit
827:16	2	AnArray
827:25	52	[
827:26	2	G
827:27	53	]
828:3	3	/   General one dimensional array  
829:3	48	(
829:4	49	)
829:7	48	(
829:8	2	pos
829:11	56	:
829:14	2	Integer
829:21	49	)
829:22	56	:
829:25	2	G
830:5	3	/ Get array element at position pos
831:5	34	require
832:7	2	count
832:14	4	>
832:17	5	0
832:20	3	/ Array is not empty
833:7	2	lower
833:14	4	<=
833:18	2	pos
833:23	2	and
833:28	2	then
833:34	2	pos
833:39	4	<=
833:43	2	upper
833:50	3	/ Valid element index
834:5	45	virtual
835:3	19	end
836:3	48	(
836:4	49	)
836:7	48	(
836:8	2	pos
836:11	56	:
836:14	2	Integer
836:25	2	value
836:30	56	:
836:33	2	G
836:34	49	)
837:5	3	/ Set array element at position pos with value
838:5	34	require
839:7	2	count
839:14	4	>
839:17	5	0
839:20	3	/ Array is not empty
840:7	2	lower
840:14	4	<=
840:18	2	pos
840:23	2	and
840:28	2	then
840:34	2	pos
840:39	4	<=
840:43	2	upper
840:50	3	/ Valid element index 
841:5	45	virtual
842:3	19	end
843:3	12	final
843:10	2	count
843:15	56	:
843:18	2	Integer
843:27	4	=>
843:31	2	upper
843:38	10	
843:39	10	
843:40	10	
843:43	2	lower
843:50	4	+
843:53	5	1
844:5	3	/ Number of elelments in the array
846:3	2	lower
846:8	56	:
846:11	2	Integer
846:20	45	virtual
847:5	3	/ Lower index value
848:3	2	upper
848:8	56	:
848:11	2	Integer
848:20	45	virtual
849:5	3	/ Upper index value
850:3	48	(
850:4	49	)
850:7	48	(
850:8	2	from
850:12	57	,
850:15	2	to
850:17	56	:
850:20	2	Integer
850:27	49	)
850:28	56	:
850:31	12	as
850:35	40	this
850:43	3	 get subarray
851:3	34	require
852:5	2	from
852:11	4	<=
852:15	2	to
852:19	3	/ subarray not empty		
853:5	2	lower
853:12	4	<=
853:16	2	from
853:22	3	/ from is greater or equal than lower
854:5	2	to
854:9	4	<=
854:13	2	upper
854:20	3	/ to is less or equal than upper
855:3	45	virtual
856:3	20	ensure
857:5	35	return
857:11	59	.
857:12	2	count
857:19	4	=
857:22	2	to
857:26	4	-
857:29	2	from
857:35	4	+
857:38	5	1
857:41	3	/ resulting subarray has valid number of elements 
858:3	19	end
859:3	48	(
859:4	49	)
859:7	48	(
859:8	2	start
859:13	56	:
859:16	2	Integer
859:27	2	subArray
859:35	56	:
859:38	12	as
859:42	40	this
859:46	49	)
859:51	3	 put subarray
860:3	34	require
861:5	2	lower
861:12	4	<=
861:16	2	start
861:23	2	and
861:28	2	then
861:34	2	start
861:41	4	<=
861:45	2	upper
861:52	3	/ valid start position of subarray to be put
862:5	2	start
862:12	4	+
862:15	2	subArray
862:23	59	.
862:24	2	count
862:31	4	-
862:34	5	1
862:37	4	<=
862:41	2	upper
862:48	3	/ valid subarray length
863:3	16	do
864:5	47	while
864:12	2	pos
864:17	25	in
864:21	2	start
864:28	58	..
864:32	2	start
864:39	4	+
864:42	2	subArray
864:50	59	.
864:51	2	count
864:58	4	-
864:61	5	1
864:64	16	do
865:7	40	this
865:13	48	(
865:14	2	pos
865:17	49	)
865:20	55	:=
865:24	2	subArray
865:34	48	(
865:35	2	subArray
865:43	59	.
865:44	2	lower
865:51	4	+
865:54	2	pos
865:59	4	-
865:62	5	1
865:63	49	)
866:5	19	end
867:3	19	end
868:1	34	require
869:3	2	count
869:10	4	>=
869:14	5	0
869:17	3	/ Consistent array count must be greater than zero
870:3	2	lower
870:10	4	<=
870:14	2	upper
870:21	4	-
870:24	5	1
870:27	3	/ Consistent  array range  lower index is not greater than upper when array is not empty. Array is empty when lower = upper - 1
871:1	19	end
871:6	3	 AnArray [G]
873:1	45	virtual
873:10	41	unit
873:16	2	OneDimentionalArray
873:37	52	[
873:38	2	G
873:41	26	init
873:47	48	(
873:48	49	)
873:49	53	]
873:52	21	extend
873:60	2	AnArray
873:69	52	[
873:70	2	G
873:71	53	]
874:3	30	override
874:13	48	(
874:14	49	)
874:17	48	(
874:18	2	pos
874:21	56	:
874:24	2	Integer
874:31	49	)
874:32	56	:
874:35	2	G
874:38	23	foreign
875:3	30	override
875:13	48	(
875:14	49	)
875:17	48	(
875:18	2	pos
875:21	56	:
875:24	2	Integer
875:35	2	value
875:40	56	:
875:43	2	G
875:44	49	)
875:47	23	foreign
876:3	30	override
876:13	31	pure
876:19	48	(
876:20	49	)
876:23	48	(
876:24	2	from
876:28	57	,
876:31	2	to
876:33	56	:
876:36	2	Integer
876:43	49	)
876:44	56	:
876:47	2	Array
876:54	52	[
876:55	2	G
876:56	53	]
877:3	3	/ get subarray
878:3	16	do
879:5	2	result
879:13	27	is
879:17	28	new
879:22	2	Array
879:29	52	[
879:30	2	G
879:31	53	]
879:32	59	.
879:33	26	init
879:37	48	(
879:38	2	from
879:42	57	,
879:45	2	to
879:47	49	)
880:5	47	while
880:12	2	pos
880:17	25	in
880:21	2	from
880:27	58	..
880:31	2	to
880:35	16	do
881:7	2	result
881:15	48	(
881:16	2	pos
881:19	49	)
881:22	55	:=
881:26	40	this
881:32	48	(
881:33	2	pos
881:36	49	)
882:5	19	end
883:5	35	return
883:13	2	result
884:3	19	end
885:1	19	end
887:1	41	unit
887:7	2	Array
887:14	52	[
887:15	2	G
887:18	26	init
887:24	48	(
887:25	49	)
887:26	57	,
887:29	2	N
887:30	56	:
887:33	2	Integer
887:40	53	]
887:43	21	extend
887:51	2	OneDimentionalArray
887:72	52	[
887:73	2	G
887:74	53	]
888:3	3	/   One dimentional static array .... WIP !!!
889:1	3	
	a0 is Array [Integer, 5]
	// That is what we like to have ....

893:3	30	override
893:13	2	lower
893:18	56	:
893:21	2	Integer
893:30	27	is
893:34	5	1
894:3	30	override
894:13	2	upper
894:18	56	:
894:21	2	Integer
894:30	27	is
894:34	2	N
896:3	26	init
896:9	48	(
896:10	2	other
896:15	56	:
896:18	12	as
896:22	40	this
896:26	49	)
896:29	16	do
897:5	47	while
897:12	2	pos
897:17	25	in
897:21	2	other
897:26	59	.
897:27	2	lower
897:34	58	..
897:38	2	other
897:43	59	.
897:44	2	upper
897:51	16	do
898:7	40	this
898:13	48	(
898:14	2	lower
898:21	4	+
898:24	2	pos
898:29	4	-
898:32	5	1
898:33	49	)
898:36	55	:=
898:40	2	other
898:47	48	(
898:48	2	pos
898:51	49	)
899:5	19	end
900:3	19	end
902:3	26	init
902:9	16	do
903:5	2	element
903:14	27	is
903:18	28	new
903:23	2	G
903:24	59	.
903:25	26	init
904:5	47	while
904:12	2	pos
904:17	25	in
904:21	2	lower
904:28	58	..
904:32	2	upper
904:39	16	do
905:7	40	this
905:13	48	(
905:14	2	pos
905:17	49	)
905:20	55	:=
905:24	2	element
906:5	19	end
907:3	19	end
908:1	19	end
908:6	3	 Array [G extend Any init (), N: Integer]
910:1	41	unit
910:7	2	Array
910:14	52	[
910:15	2	G
910:18	26	init
910:24	48	(
910:25	49	)
910:26	57	,
910:29	2	N
910:30	56	:
910:33	48	(
910:34	2	Integer
910:41	57	,
910:42	2	Integer
910:49	49	)
910:50	53	]
910:53	21	extend
910:61	2	OneDimentionalArray
910:82	52	[
910:83	2	G
910:84	53	]
911:3	3	/   One dimentional static array .... WIP !!!
912:1	3	
	a1 is Array [Real, (10,25)]
	// That is what we like to have ....

916:3	30	override
916:13	2	lower
916:18	56	:
916:21	2	Integer
916:30	27	is
916:34	2	N
916:35	48	(
916:36	5	1
916:37	49	)
917:3	30	override
917:13	2	upper
917:18	56	:
917:21	2	Integer
917:30	27	is
917:34	2	N
917:35	48	(
917:36	5	2
917:37	49	)
918:3	26	init
918:9	48	(
918:10	2	other
918:15	56	:
918:18	12	as
918:22	40	this
918:26	49	)
918:29	16	do
919:5	47	while
919:12	2	pos
919:17	25	in
919:21	2	other
919:26	59	.
919:27	2	lower
919:34	58	..
919:38	2	other
919:43	59	.
919:44	2	upper
919:51	16	do
920:7	40	this
920:13	48	(
920:14	2	lower
920:21	4	+
920:24	2	pos
920:29	4	-
920:32	5	1
920:33	49	)
920:36	55	:=
920:40	2	other
920:47	48	(
920:48	2	pos
920:51	49	)
921:5	19	end
922:3	19	end
923:3	26	init
923:9	16	do
924:5	2	element
924:14	27	is
924:18	28	new
924:23	2	G
924:24	59	.
924:25	26	init
925:5	47	while
925:12	2	pos
925:17	25	in
925:21	2	lower
925:28	58	..
925:32	2	upper
925:39	16	do
926:7	40	this
926:13	48	(
926:14	2	pos
926:17	49	)
926:20	55	:=
926:24	2	element
927:5	19	end
928:3	19	end
929:1	19	end
929:6	3	 Array [G extend Any init (), N: (Integer,Integer)]
932:1	41	unit
932:7	2	Array
932:14	52	[
932:15	2	G
932:18	26	init
932:24	48	(
932:25	49	)
932:26	53	]
932:29	21	extend
932:37	2	OneDimentionalArray
932:58	52	[
932:59	2	G
932:60	53	]
933:1	3	/   Dynamic array
934:1	3	 We can put info Array only objects which has constructor with empty signature !!! We are always safe - no uninitilized data!!! 
935:3	30	override
935:13	48	(
935:14	49	)
935:17	48	(
935:18	2	pos
935:21	56	:
935:24	2	Integer
935:31	49	)
935:32	56	:
935:35	2	G
935:38	23	foreign
936:3	30	override
936:13	48	(
936:14	49	)
936:17	48	(
936:18	2	pos
936:21	56	:
936:24	2	Integer
936:35	2	value
936:40	56	:
936:43	2	G
936:44	49	)
936:47	23	foreign
937:3	30	override
937:13	44	var
937:18	2	lower
937:23	56	:
937:26	2	Integer
938:3	30	override
938:13	44	var
938:18	2	upper
938:23	56	:
938:26	2	Integer
939:3	26	init
940:5	3	/ It creates an empty array, but lower index is set a 1
941:3	16	do
942:5	26	init
942:11	48	(
942:12	5	1
942:13	57	,
942:16	5	0
942:17	57	,
942:20	2	G
942:21	48	(
942:22	49	)
942:23	49	)
943:3	19	end
944:3	26	init
944:9	48	(
944:10	2	n
944:11	56	:
944:14	2	Integer
944:25	2	value
944:30	56	:
944:33	2	G
944:34	49	)
945:5	3	/ It creates an array of n elements,  lower index is 1
946:3	34	require
947:5	2	n
947:8	4	>=
947:12	5	0
948:3	16	do
949:5	26	init
949:11	48	(
949:12	5	1
949:13	57	,
949:16	2	n
949:17	57	,
949:20	2	value
949:25	49	)
950:3	19	end
951:3	26	init
951:9	48	(
951:10	2	n
951:11	56	:
951:14	2	Integer
951:21	49	)
952:3	34	require
953:5	2	n
953:8	4	>=
953:12	5	0
954:3	16	do
955:5	26	init
955:11	48	(
955:12	5	1
955:13	57	,
955:16	2	n
955:17	57	,
955:20	2	G
955:21	48	(
955:22	49	)
955:23	49	)
956:3	19	end
957:3	26	init
957:9	48	(
957:10	2	l
957:11	57	,
957:14	2	u
957:15	56	:
957:18	2	Integer
957:25	49	)
957:28	16	do
958:5	26	init
958:11	48	(
958:12	2	l
958:13	57	,
958:16	2	u
958:17	57	,
958:20	2	G
958:21	48	(
958:22	49	)
958:23	49	)
959:3	19	end
960:3	26	init
960:9	48	(
960:10	2	l
960:11	57	,
960:14	2	u
960:15	56	:
960:18	2	Integer
960:29	2	value
960:34	56	:
960:37	2	G
960:38	49	)
961:3	34	require
962:5	2	l
962:8	4	<=
962:12	2	u
962:15	4	-
962:18	5	1
962:21	3	/ Consistent array borders, lower must be not greater than upper if array is not empty and 1 less than upper otherwise
963:3	16	do
964:5	2	lower
964:12	55	:=
964:16	2	l
965:5	2	upper
965:12	55	:=
965:16	2	u
966:5	2	fill
966:11	48	(
966:12	2	value
966:17	49	)
967:3	19	end
968:3	50	{
968:4	51	}
968:7	2	fill
968:13	48	(
968:14	2	value
968:19	56	:
968:22	2	G
968:23	49	)
968:26	16	do
969:5	24	if
969:9	2	lower
969:16	4	<=
969:20	2	upper
969:27	16	do
970:7	2	data
970:13	55	:=
970:17	2	allocateArray
970:32	48	(
970:33	2	lower
970:38	57	,
970:41	2	upper
970:46	57	,
970:49	2	value
970:54	59	.
970:55	2	sizeof
970:61	49	)
971:7	47	while
971:14	2	index
971:21	25	in
971:25	2	lower
971:32	58	..
971:36	2	upper
971:43	16	do
972:9	40	this
972:15	48	(
972:16	2	index
972:21	49	)
972:24	55	:=
972:28	2	value
973:7	19	end
974:5	19	end
975:3	19	end
976:3	50	{
976:4	51	}
976:7	44	var
976:12	2	data
976:16	56	:
976:19	60	?
976:20	2	Pointer
977:3	50	{
977:4	51	}
977:7	23	foreign
977:16	2	allocateArray
977:31	48	(
977:32	2	l
977:33	57	,
977:36	2	u
977:37	56	:
977:40	2	Integer
977:47	56	:
977:50	2	size
977:54	56	:
977:57	2	Integer
977:64	49	)
978:3	34	require
979:5	2	l
979:8	4	<=
979:12	2	u
979:15	3	/ Consistent array borders
980:3	19	end
981:1	19	end
981:6	3	 Array [G extend Any init ()]
983:1	41	unit
983:7	2	Array
983:14	52	[
983:15	2	G
983:18	26	init
983:24	48	(
983:25	49	)
983:26	57	,
983:29	2	dimentions
983:39	56	:
983:42	48	(
983:43	2	Integer
983:50	4	|
983:51	2	Integer
983:60	58	..
983:64	2	Integer
983:71	49	)
983:72	53	]
983:75	21	extend
983:83	2	Array
983:90	52	[
983:91	2	G
983:92	57	,
983:95	2	numberOfElementsInLinearArray
983:126	53	]
984:1	3	/   Multi dimentional static array .... WIP!!!
985:1	3	
	a0 is Array [Integer, (5, 4)]
	a1 is Array [Real, (1..4, 5..7, 3..7)]
	// That is what we like to have ....

990:3	3	{} data: Array [G ......] /// Multi dimetional array is to be stored as one dimentional one!!! 
991:3	50	{
991:4	51	}
991:7	2	numberOfElementsInLinearArray
991:36	56	:
991:39	2	Integer
991:48	16	do
992:5	44	var
992:10	2	result
992:18	27	is
992:22	5	0
993:5	47	while
993:12	2	dim
993:17	25	in
993:21	2	dimentions
993:33	16	do
994:7	24	if
994:11	2	dim
994:16	27	is
995:9	2	Integer
995:16	56	:
996:11	2	result
996:19	55	:=
996:23	2	result
996:31	4	+
996:34	2	dim
997:9	2	Integer
997:18	58	..
997:22	2	Integer
997:29	56	:
998:11	2	result
998:19	55	:=
998:23	2	result
998:31	4	+
998:34	2	dim
998:37	59	.
998:38	2	last
998:44	4	-
998:47	2	dim
998:50	59	.
998:51	2	first
998:58	4	+
998:61	5	1
999:7	17	else
1000:9	32	raise
1000:16	8	Bad array
1001:7	19	end
1002:5	19	end
1003:5	35	return
1003:13	2	result
1004:3	19	end
1005:1	19	end
1005:6	3	 Array [G extend Any init (), dimentions: (Integer|Integer .. Integer)]
1007:1	41	unit
1007:7	2	StandardIO
1008:3	2	readInt
1008:10	56	:
1008:13	2	Integer
1008:22	23	foreign
1009:3	2	readReal
1009:11	56	:
1009:14	2	Real
1009:20	23	foreign
1010:3	2	readBoolean
1010:14	56	:
1010:17	2	Boolean
1010:26	23	foreign
1011:3	2	readChar
1011:11	56	:
1011:14	2	Char
1011:20	23	foreign
1012:3	2	readString
1012:13	56	:
1012:16	2	String
1012:24	23	foreign
1013:3	3	 Init procedure is missed or how to set the output is missed !!!!
1014:3	31	pure
1014:9	2	put
1014:14	11	alias
1014:21	2	print
1014:28	48	(
1014:29	2	arguments
1014:38	56	:
1014:41	48	(
1014:42	49	)
1014:43	49	)
1014:46	16	do
1015:5	47	while
1015:12	2	argument
1015:22	25	in
1015:26	2	arguments
1015:37	16	do
1016:7	24	if
1016:11	2	argument
1016:21	27	is
1017:9	2	Integer
1017:16	56	:
1018:11	2	putInteger
1018:23	48	(
1018:24	2	argument
1018:32	49	)
1019:9	2	Character
1019:18	56	:
1020:11	2	putCharacter
1020:25	48	(
1020:26	2	argument
1020:34	49	)
1021:9	2	String
1021:15	56	:
1022:11	2	putString
1022:22	48	(
1022:23	2	argument
1022:31	49	)
1023:9	2	Real
1023:13	56	:
1024:11	2	putReal
1024:20	48	(
1024:21	2	argument
1024:29	49	)
1025:9	2	Boolean
1025:16	56	:
1026:11	2	putBoolean
1026:23	48	(
1026:24	2	argument
1026:32	49	)
1027:9	17	else
1028:11	2	putString
1028:22	48	(
1028:23	2	argument
1028:31	59	.
1028:32	2	ToString
1028:40	49	)
1029:7	19	end
1030:5	19	end
1031:3	19	end
1031:8	2	put
1032:3	50	{
1032:4	51	}
1032:7	2	putInteger
1032:19	48	(
1032:20	2	anInteger
1032:29	56	:
1032:32	2	Integer
1032:39	49	)
1032:42	23	foreign
1033:3	50	{
1033:4	51	}
1033:7	2	putCharacter
1033:21	48	(
1033:22	2	aCharacter
1033:32	56	:
1033:35	2	Character
1033:44	49	)
1033:47	23	foreign
1034:3	50	{
1034:4	51	}
1034:7	2	putString
1034:18	48	(
1034:19	2	aString
1034:26	56	:
1034:29	2	String
1034:35	49	)
1034:38	23	foreign
1035:3	50	{
1035:4	51	}
1035:7	2	putReal
1035:16	48	(
1035:17	2	aReal
1035:22	56	:
1035:25	2	Real
1035:29	49	)
1035:32	23	foreign
1036:3	50	{
1036:4	51	}
1036:7	2	putBoolean
1036:19	48	(
1036:20	2	aBoolean
1036:28	56	:
1036:31	2	Boolean
1036:38	49	)
1036:41	23	foreign
1037:1	19	end
1037:6	3	 StandardIO
1039:1	3	 How to deal with dynamic objects .... WIP !!!
1040:1	41	unit
1040:7	2	DynamicObject
1041:3	3	 This unit allows to deal with dynamically loaded/created objects 
	providing dynamic type checking.
	
1044:3	3	 Access members by name
1045:3	12	final
1045:10	2	call
1045:16	48	(
1045:17	2	rtn_name
1045:25	56	:
1045:28	2	String
1045:38	2	args
1045:42	56	:
1045:45	48	(
1045:46	49	)
1045:47	49	)
1045:50	16	do
1046:5	2	rtn_descr
1046:16	27	is
1046:20	2	findRoutine
1046:31	48	(
1046:32	2	rtn_name
1046:40	49	)
1047:5	24	if
1047:9	2	rtn_descr
1047:20	27	is
1047:24	2	ProcedureDescriptor
1047:45	16	do
1048:7	2	call
1048:13	48	(
1048:14	2	rtn_descr
1048:23	57	,
1048:26	2	args
1048:30	49	)
1049:5	17	else
1050:7	32	raise
1050:14	8	Call to non-existing procedure '
1050:50	4	+
1050:53	2	rtn_name
1050:63	4	+
1050:66	8	'
1051:5	19	end
1052:3	19	end
1053:3	12	final
1053:10	2	call
1053:16	48	(
1053:17	2	rtn_name
1053:25	56	:
1053:28	2	String
1053:38	2	args
1053:42	56	:
1053:45	48	(
1053:46	49	)
1053:47	49	)
1053:48	56	:
1053:51	2	Any
1053:56	16	do
1054:5	2	rtn_descr
1054:16	27	is
1054:20	2	findRoutine
1054:31	48	(
1054:32	2	rtn_name
1054:40	49	)
1055:5	24	if
1055:9	2	rtn_descr
1055:20	27	is
1055:24	2	FunctionDescriptor
1055:44	16	do
1056:7	35	return
1056:15	2	call
1056:21	48	(
1056:22	2	rtn_descr
1056:31	57	,
1056:34	2	args
1056:38	49	)
1057:5	17	else
1058:7	32	raise
1058:14	8	Call to non-existing function '
1058:49	4	+
1058:52	2	rtn_name
1058:62	4	+
1058:65	8	'
1059:5	19	end
1060:3	19	end
1061:3	12	final
1061:10	2	get_value
1061:21	48	(
1061:22	2	attr_name
1061:31	56	:
1061:34	2	String
1061:40	49	)
1061:41	56	:
1061:44	2	Any
1061:49	16	do
1062:5	2	attr_descr
1062:17	27	is
1062:21	2	findAttribute
1062:36	48	(
1062:37	2	attr_name
1062:46	49	)
1063:5	24	if
1063:9	2	attr_descr
1063:21	27	is
1063:25	2	AttributeDescriptor
1063:46	16	do
1064:7	35	return
1064:15	2	attr_descr
1064:25	59	.
1064:26	2	value
1065:5	17	else
1066:7	32	raise
1066:14	8	Access to non-existing attribute '
1066:52	4	+
1066:55	2	attr_name
1066:66	4	+
1066:69	8	'
1067:5	19	end
1068:3	19	end
1069:3	12	final
1069:10	2	set_value
1069:21	48	(
1069:22	2	attr_name
1069:31	56	:
1069:34	2	String
1069:44	2	value
1069:49	56	:
1069:52	2	Any
1069:55	49	)
1069:58	16	do
1070:5	2	attr_descr
1070:17	27	is
1070:21	2	findAttribute
1070:36	48	(
1070:37	2	attr_name
1070:46	49	)
1071:5	24	if
1071:9	2	attr_descr
1071:21	27	is
1071:25	2	VariableDescriptor
1071:45	16	do
1072:7	2	attr_descr
1072:17	59	.
1072:18	2	value
1072:25	55	:=
1072:29	2	value
1073:5	17	else
1074:7	32	raise
1074:14	8	Access to non-existing/writable attribute '
1074:61	4	+
1074:64	2	attr_name
1074:75	4	+
1074:78	8	'
1075:5	19	end
1076:3	19	end
1077:3	3	 Access members by object (address) 
1078:3	12	final
1078:10	2	routines
1078:18	48	(
1078:19	49	)
1078:22	56	:
1078:25	2	Array
1078:32	52	[
1078:33	2	RoutineDecsriptor
1078:50	53	]
1078:53	23	foreign
1079:3	12	final
1079:10	2	attributes
1079:22	48	(
1079:23	49	)
1079:24	56	:
1079:27	2	Array
1079:34	52	[
1079:35	2	AttributeDescriptor
1079:54	53	]
1079:57	23	foreign
1080:3	12	final
1080:10	2	call
1080:16	48	(
1080:17	37	rtn
1080:20	56	:
1080:23	2	ProcedureDecsriptor
1080:46	2	args
1080:50	56	:
1080:53	48	(
1080:54	49	)
1080:55	49	)
1080:58	23	foreign
1081:3	12	final
1081:10	2	call
1081:16	48	(
1081:17	37	rtn
1081:20	56	:
1081:23	2	FunctionDecsriptor
1081:45	2	args
1081:49	56	:
1081:52	48	(
1081:53	49	)
1081:54	49	)
1081:55	56	:
1081:58	2	Any
1081:63	23	foreign
1082:3	12	final
1082:10	2	get_value
1082:21	48	(
1082:22	2	attr
1082:26	56	:
1082:29	2	AttributeDescriptor
1082:48	49	)
1082:49	56	:
1082:52	2	Any
1082:57	4	=>
1082:61	2	attr
1082:65	59	.
1082:66	2	value
1083:3	12	final
1083:10	2	set_value
1083:21	48	(
1083:22	2	attr
1083:26	56	:
1083:29	2	VariableDescriptor
1083:51	2	value
1083:56	56	:
1083:59	2	Any
1083:62	49	)
1083:65	23	foreign
1084:3	12	final
1084:10	50	{
1084:11	51	}
1084:14	2	own
1084:19	2	findRoutine
1084:32	48	(
1084:33	2	rtn_name
1084:41	56	:
1084:44	2	String
1084:50	49	)
1084:51	56	:
1084:54	60	?
1084:55	2	RoutineDescriptor
1084:74	23	foreign
1085:3	12	final
1085:10	50	{
1085:11	51	}
1085:14	2	own
1085:19	2	findAttribute
1085:34	48	(
1085:35	2	attr_name
1085:44	56	:
1085:47	2	String
1085:53	49	)
1085:54	56	:
1085:57	60	?
1085:58	2	AttributeDescriptor
1085:79	23	foreign
1086:3	26	init
1086:9	16	do
1087:5	3	/ Create empty dynamic object
1088:3	19	end
1089:3	26	init
1089:9	48	(
1089:10	2	fileName
1089:18	56	:
1089:21	2	String
1089:27	49	)
1089:30	16	do
1090:5	3	/ Load dynamic object from file
1091:5	32	raise
1091:12	8	Not implemented yet!!!
1092:3	19	end
1093:3	26	init
1093:9	48	(
1093:10	2	bytes
1093:15	56	:
1093:18	2	Array
1093:25	52	[
1093:26	2	Byte
1093:30	53	]
1093:31	49	)
1093:34	23	foreign
1094:5	3	/ Create dynamic object from binary data sequence
1095:3	26	init
1095:9	48	(
1095:10	2	other
1095:15	56	:
1095:18	2	Any
1095:21	49	)
1095:24	23	foreign
1096:5	3	/ Create dynamic object from any other object
1098:1	19	end
1100:1	45	virtual
1100:10	41	unit
1100:16	2	MemberDescriptor
1101:3	12	final
1101:10	44	var
1101:15	2	name
1101:19	56	:
1101:22	2	String
1102:1	19	end
1103:1	45	virtual
1103:10	41	unit
1103:16	2	RoutineDescriptor
1103:35	21	extend
1103:43	2	MemberDescriptor
1104:3	12	final
1104:10	44	var
1104:15	2	arguments
1104:24	56	:
1104:27	2	Array
1104:34	52	[
1104:35	2	ArgumentDescriptor
1104:53	53	]
1105:1	19	end
1105:6	3	 RoutineDescriptor
1107:1	12	final
1107:8	41	unit
1107:14	2	ProcedureDescriptor
1107:35	21	extend
1107:43	2	RoutineDescriptor
1108:3	48	(
1108:4	49	)
1108:7	11	alias
1108:14	2	apply
1108:21	48	(
1108:22	2	args
1108:26	56	:
1108:29	48	(
1108:30	49	)
1108:31	49	)
1108:34	23	foreign
1109:5	3	 That is a procedure call
1110:3	26	init
1110:9	48	(
1110:10	2	aName
1110:15	56	:
1110:18	12	as
1110:22	2	name
1110:30	2	args
1110:34	56	:
1110:37	12	as
1110:41	2	arguments
1110:50	49	)
1110:53	16	do
1111:5	2	name
1111:11	55	:=
1111:15	2	aName
1112:5	2	arguments
1112:16	55	:=
1112:20	2	args
1113:3	19	end
1114:1	19	end
1114:6	3	 Procedure [Arguments -> ()]
1116:1	12	final
1116:8	41	unit
1116:14	2	FunctionDescriptor
1116:34	21	extend
1116:42	2	RoutineDescriptor
1117:3	44	var
1117:8	2	type
1117:12	56	:
1117:15	2	TypeDescriptor
1118:3	48	(
1118:4	49	)
1118:7	11	alias
1118:14	2	apply
1118:21	48	(
1118:22	2	args
1118:26	56	:
1118:29	2	Arguments
1118:38	49	)
1118:39	56	:
1118:42	2	Result
1118:50	23	foreign
1119:5	3	 That is a function call
1120:3	26	init
1120:9	48	(
1120:10	2	aName
1120:15	56	:
1120:18	12	as
1120:22	2	name
1120:30	2	args
1120:34	56	:
1120:37	12	as
1120:41	2	arguments
1120:54	2	aType
1120:59	56	:
1120:62	12	as
1120:66	2	type
1120:70	49	)
1120:73	16	do
1121:5	2	name
1121:11	55	:=
1121:15	2	aName
1122:5	2	arguments
1122:16	55	:=
1122:20	2	args
1123:5	2	type
1123:11	55	:=
1123:15	2	aType
1124:3	19	end
1125:1	19	end
1125:6	3	 Function [Arguments -> (), Result]*/
1127:1	45	virtual
1127:10	41	unit
1127:16	2	AttributeDescriptor
1127:37	21	extend
1127:45	2	MemberDescriptor
1128:3	44	var
1128:8	2	value
1128:13	56	:
1128:16	2	Any
1129:3	44	var
1129:8	2	type
1129:12	56	:
1129:15	2	TypeDescriptor
1130:1	19	end
1130:6	3	 AttributeDescriptor
1132:1	12	final
1132:8	41	unit
1132:14	2	VariableDescriptor
1132:36	21	extend
1132:44	2	AttributeDescriptor
1133:3	30	override
1133:13	55	:=
1133:17	11	alias
1133:24	2	set
1133:27	48	(
1133:28	2	v
1133:29	56	:
1133:32	12	as
1133:36	2	value
1133:41	49	)
1133:44	16	do
1134:5	2	value
1134:12	55	:=
1134:16	2	v
1135:3	19	end
1136:3	26	init
1136:9	48	(
1136:10	2	aName
1136:15	56	:
1136:18	12	as
1136:22	2	name
1136:30	2	aType
1136:35	56	:
1136:38	12	as
1136:42	2	type
1136:50	2	aValue
1136:56	56	:
1136:59	12	as
1136:63	2	value
1136:68	49	)
1136:71	16	do
1137:5	2	name
1137:11	55	:=
1137:15	2	aName
1138:5	2	type
1138:11	55	:=
1138:15	2	aType
1139:5	2	value
1139:12	55	:=
1139:16	2	aValue
1140:3	19	end
1141:1	19	end
1141:6	3	 VariableDescriptor
1143:1	12	final
1143:8	41	unit
1143:14	2	ConstantDescriptor
1143:36	21	extend
1143:44	2	AttributeDescriptor
1144:3	26	init
1144:9	48	(
1144:10	2	aName
1144:15	56	:
1144:18	12	as
1144:22	2	name
1144:30	2	aType
1144:35	56	:
1144:38	12	as
1144:42	2	type
1144:50	2	aValue
1144:56	56	:
1144:59	12	as
1144:63	2	value
1144:68	49	)
1144:71	16	do
1145:5	2	name
1145:11	55	:=
1145:15	2	aName
1146:5	2	type
1146:11	55	:=
1146:15	2	aType
1147:5	2	value
1147:12	55	:=
1147:16	2	aValue
1148:3	19	end
1149:1	19	end
1149:6	3	 ConstantDescriptor
1151:1	12	final
1151:8	41	unit
1151:14	2	TypeDescriptior
1152:3	12	final
1152:10	44	var
1152:15	2	name
1152:19	56	:
1152:22	2	String
1153:3	12	final
1153:10	44	var
1153:15	2	routines
1153:25	56	:
1153:28	2	Array
1153:35	52	[
1153:36	2	RoutineDecsriptor
1153:53	53	]
1154:3	12	final
1154:10	44	var
1154:15	2	attributes
1154:27	56	:
1154:30	2	Array
1154:37	52	[
1154:38	2	AttributeDescriptor
1154:57	53	]
1155:3	12	final
1155:10	44	var
1155:15	2	parents
1155:22	56	:
1155:25	2	Array
1155:32	52	[
1155:33	2	TypeDesciptor
1155:46	53	]
1156:3	26	init
1156:9	48	(
1156:10	2	aName
1156:15	56	:
1156:18	12	as
1156:22	2	name
1156:30	2	prtns
1156:35	56	:
1156:38	12	as
1156:42	2	parents
1156:53	2	rtns
1156:57	56	:
1156:60	12	as
1156:64	2	routines
1156:76	2	attrs
1156:81	56	:
1156:84	12	as
1156:88	2	attributes
1156:98	49	)
1156:101	16	do
1157:5	2	name
1157:11	55	:=
1157:15	2	aName
1158:5	2	parents
1158:14	55	:=
1158:18	2	prtns
1159:5	2	routines
1159:15	55	:=
1159:19	2	rtns
1160:5	2	attributes
1160:17	55	:=
1160:21	2	attrs
1161:3	19	end
1162:1	19	end
1163:0	1	<EOF>
